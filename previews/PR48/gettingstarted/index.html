<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Getting Started with ADI.jl · ADI.jl</title><link rel="canonical" href="https://juliahci.github.io/ADI.jl/gettingstarted/"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">ADI.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../introduction/">Introduction to HCI</a></li><li class="is-active"><a class="tocitem" href>Getting Started with ADI.jl</a><ul class="internal"><li><a class="tocitem" href="#Expected-Data-Formats"><span>Expected Data Formats</span></a></li><li><a class="tocitem" href="#Algorithms"><span>Algorithms</span></a></li><li><a class="tocitem" href="#Processing-Patterns"><span>Processing Patterns</span></a></li><li><a class="tocitem" href="#Comparison-to-VIP"><span>Comparison to VIP</span></a></li><li><a class="tocitem" href="#Feature-comparison"><span>Feature comparison</span></a></li></ul></li><li><span class="tocitem">Algorithms</span><ul><li><a class="tocitem" href="../algorithms/classic/">Classic</a></li><li><a class="tocitem" href="../algorithms/pca/">PCA</a></li><li><a class="tocitem" href="../algorithms/nmf/">NMF</a></li><li><a class="tocitem" href="../algorithms/greeds/">GreeDS</a></li><li><a class="tocitem" href="../algorithms/api/">API/Reference</a></li></ul></li><li><a class="tocitem" href="../framewise/">Framewise</a></li><li><a class="tocitem" href="../sdi/">SDI</a></li><li><a class="tocitem" href="../metrics/">Metrics</a></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../examples/betapictoris/">ADI Reduction of <span>$\beta$</span> Pictoris</a></li><li><a class="tocitem" href="../examples/geometries/">Exploring spatial and temporal filtering</a></li></ul></li><li><a class="tocitem" href="../benchmarks/">Benchmarks</a></li><li><a class="tocitem" href="../api/">Index</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Getting Started with ADI.jl</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Getting Started with ADI.jl</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/juliahci/ADI.jl/blob/master/docs/src/gettingstarted.md#L" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="gettingstarted"><a class="docs-heading-anchor" href="#gettingstarted">Getting Started</a><a id="gettingstarted-1"></a><a class="docs-heading-anchor-permalink" href="#gettingstarted" title="Permalink"></a></h1><p>Here is a quick-start guide for people familiar with ADI and experience using tools like <a href="https://github.com/vortex-exoplanet/VIP">VIP</a> or <a href="https://pyklip.readthedocs.io/en/latest/">pyKLIP</a>. For installation and setup information, see the <a href="../#Installation-and-Setup">Installation and Setup</a> section.</p><h2 id="Expected-Data-Formats"><a class="docs-heading-anchor" href="#Expected-Data-Formats">Expected Data Formats</a><a id="Expected-Data-Formats-1"></a><a class="docs-heading-anchor-permalink" href="#Expected-Data-Formats" title="Permalink"></a></h2><h3 id="ADI-Cube"><a class="docs-heading-anchor" href="#ADI-Cube">ADI Cube</a><a id="ADI-Cube-1"></a><a class="docs-heading-anchor-permalink" href="#ADI-Cube" title="Permalink"></a></h3><p>For standard ADI data, we store the values in a 3-dimensional array, where the first dimension is temporal, and the remaining dimensions are pixel coordinates. This is how most ADI data are stored on disk (typically in FITS files) and allow specifying operations like a tensor. This cube should already be registered with the star in the center of the frames (note the center is only well-defined for odd-sized frames, even though even-sized frames will work fine).</p><h3 id="Parallactic-Angles"><a class="docs-heading-anchor" href="#Parallactic-Angles">Parallactic Angles</a><a id="Parallactic-Angles-1"></a><a class="docs-heading-anchor-permalink" href="#Parallactic-Angles" title="Permalink"></a></h3><p>The parallactic angles should be stored as <em>degrees</em> in a vector. The parallactic angle <code>X[i]</code> will result in rotating frame <code>i</code> <code>X[i]</code> degrees counter-clockwise.</p><h3 id="SDI-Cube/Tensor"><a class="docs-heading-anchor" href="#SDI-Cube/Tensor">SDI Cube/Tensor</a><a id="SDI-Cube/Tensor-1"></a><a class="docs-heading-anchor-permalink" href="#SDI-Cube/Tensor" title="Permalink"></a></h3><p>For standard SDI data, we store the values in a 4-dimensional array, where the first dimension is spectral, the second is temporal, and the remaining dimensions are pixel coordinates. This is how <em>some</em> SDI data are stored on disk (typically in FITS files) and allow specifying operations like a tensor. For SDI data that is stored with the temporal axis first, the dimensions should be permuted before processing (see <code>permutedims</code>). This cube should also be registered with the star in the center of the frame.</p><p>In addition to the SDI tensor and parallactic angles, the list of wavelengths are required (for scaling speckles) and a spectral template can be used. To create a scale list from the wavelengths, use <a href="../sdi/#HCIToolbox.scale_list"><code>scale_list</code></a>. Currently there is not support for spectral templates.</p><h2 id="Algorithms"><a class="docs-heading-anchor" href="#Algorithms">Algorithms</a><a id="Algorithms-1"></a><a class="docs-heading-anchor-permalink" href="#Algorithms" title="Permalink"></a></h2><p>The following algorithms are implemented:</p><ul><li><a href="../algorithms/classic/#classic">Classic Subtraction</a></li><li><a href="../algorithms/pca/#pca">PCA</a></li><li><a href="../algorithms/nmf/#nmf">NMF</a></li><li><a href="../algorithms/greeds/#greeds">GreeDS</a></li></ul><h2 id="Processing-Patterns"><a class="docs-heading-anchor" href="#Processing-Patterns">Processing Patterns</a><a id="Processing-Patterns-1"></a><a class="docs-heading-anchor-permalink" href="#Processing-Patterns" title="Permalink"></a></h2><h3 id="Full-Frame-ADI-Reduction"><a class="docs-heading-anchor" href="#Full-Frame-ADI-Reduction">Full Frame ADI Reduction</a><a id="Full-Frame-ADI-Reduction-1"></a><a class="docs-heading-anchor-permalink" href="#Full-Frame-ADI-Reduction" title="Permalink"></a></h3><p>Given an algorithm <code>alg</code>, we can fully process ADI data by calling <code>alg</code> like a function, or using the <a href="../algorithms/api/#ADI.process"><code>process</code></a> method</p><pre><code class="language-julia">julia&gt; using ADI

julia&gt; alg = PCA(ncomps=5)

julia&gt; resid = alg(cube, angles)

julia&gt; resid === process(alg, cube, angles)
true</code></pre><h3 id="Full-Frame-RDI-Reduction"><a class="docs-heading-anchor" href="#Full-Frame-RDI-Reduction">Full Frame RDI Reduction</a><a id="Full-Frame-RDI-Reduction-1"></a><a class="docs-heading-anchor-permalink" href="#Full-Frame-RDI-Reduction" title="Permalink"></a></h3><p>The only difference here is the inclusion of a reference cube.</p><pre><code class="language-julia">julia&gt; alg = PCA(ncomps=5)

julia&gt; resid = alg(cube, angles; ref=cube_ref)</code></pre><h3 id="Reduction-Process"><a class="docs-heading-anchor" href="#Reduction-Process">Reduction Process</a><a id="Reduction-Process-1"></a><a class="docs-heading-anchor-permalink" href="#Reduction-Process" title="Permalink"></a></h3><p>The process for producing the flat, residual frame follows this general workflow</p><ol><li>Create a cube of the speckle approximation, <code>S</code></li><li>Subtract <code>S</code> from the data cube to create the residual cube <code>R</code></li><li>Derotate <code>R</code> frame-by-frame according to the parallactic angle</li><li>Collapse the derotated <code>R</code></li></ol><p>In ADI.jl this process looks like this:</p><pre><code class="language-julia">cube, angles = # load data
S = reconstruct(PCA(10), cube)
R = cube .- S
R_derotate = derotate(R, angles)
resid = collapse(R_derotate)

# or, more succinctly
R = subtract(PCA(10), cube)
resid = collapse(R, angles)</code></pre><p>Notice how the only part of this specific to the algorithm is <a href="../algorithms/api/#ADI.reconstruct"><code>reconstruct</code></a>? This lets us have the super-compact functional form from above without having to copy the common code for each algorithm.</p><h3 id="Altering-the-Geometry"><a class="docs-heading-anchor" href="#Altering-the-Geometry">Altering the Geometry</a><a id="Altering-the-Geometry-1"></a><a class="docs-heading-anchor-permalink" href="#Altering-the-Geometry" title="Permalink"></a></h3><p><a href="https://github.com/JuliaHCI/HCIToolbox.jl">HCIToolbox.jl</a> has utilities for geometrically filtering the input data, such as only taking an annulus of the input cube or iterating over many annuli. This is exactly the purpose of <a href="../framewise/#HCIToolbox.AnnulusView"><code>AnnulusView</code></a> and <a href="../framewise/#HCIToolbox.MultiAnnulusView"><code>MultiAnnulusView</code></a>, which use indexing tricks to retrieve the pixels <em>only</em> within the spatial region of interest without having to copy the input data.</p><p>If you wrap a cube in one of these views, ADI.jl will handle it automatically (if the algorithm supports it). Since these views filter the pixels, the runtime performance will generally be faster than the full-frame equivalents.</p><pre><code class="language-julia">ann = AnnulusView(cube; inner=15, outer=25)
res = PCA(10)(ann, angles)</code></pre><pre><code class="language-julia"># annuli of width 5 starting at 5 pixels and ending at the edge of the cube
anns = MultiAnnulusView(cube, 5; inner=5)
res = PCA(10)(anns, angles)

# use different algorithms for each annulus
N_ann = length(anns.indices)
algs = [PCA(10), PCA(9), PCA(8), ...]
res = process(algs, anns, angles)</code></pre><h2 id="Comparison-to-VIP"><a class="docs-heading-anchor" href="#Comparison-to-VIP">Comparison to VIP</a><a id="Comparison-to-VIP-1"></a><a class="docs-heading-anchor-permalink" href="#Comparison-to-VIP" title="Permalink"></a></h2><p>ADI.jl took a lot of ideas from VIP and expanded them using the power of Julia. To begin with, Julia typically has smaller and more self-contained packages, so most of the basic image-processing that is used here is actually written in the <a href="https://github.com/JuliaHCI/HCIToolbox.jl">HCIToolbox.jl</a> package. In the future, I have plans to incorporate forward-modeling distributions in <a href="https://github.com/JuliaHCI/Firefly.jl">Firefly.jl</a>, which currently is an active research project.</p><p>Some technical distinctions to VIP</p><ul><li>Julia is 1-indexed. This means all the positions for apertures, bounds, images, etc. start at 1. This is distinct from 0-based indexing in python, but is equivalent to the indexing in DS9 and IRAF.</li><li>Julia&#39;s <code>std</code> uses the sample statistic (<code>n-1</code> degrees of freedom) while numpy&#39;s <code>std</code> uses the population statistic (<code>n</code> degrees of freedom). This may cause very slight differences in measurements that rely on this.</li><li>Aperture mapping - many of the <a href="../metrics/#ADI.Metrics"><code>Metrics</code></a> are derived by measuring statistics in an annulus of apertures. In VIP, this ring is not equally distributed- the angle between apertures is based on the exact number of apertures rather than the integral number of apertures that are actually measured. In ADI.jl the angle between apertures is evenly distributed. The same number of pixels are discarded in both packages, but in VIP they all end up in the same region of the image (see <a href="../assets/aperture_masks.png">this figure</a>).</li><li>Collapsing - by default VIP collapses a cube by derotating it then finding the median frame. In ADI.jl, the default collapse method is a weighted sum using the inverse of the temporal variance for weighting. This is documented in <code>HCIToolbox.collapse</code> and can be overridden by passing the keyword argument <code>method=median</code> or whichever statistical funciton you want to use.</li><li>Image interpolation - by default VIP uses a <code>lanczos4</code> interpolator from opencv, by default ADI.jl uses a bilinear b-spline interpolator through Interpolations.jl</li><li>Annular and framewise processing - some of the VIP algorithms allow you to go annulus-by-annulus and optionally filter the frames using parallactic angle thresholds. ADI.jl does not bake these options in using keyword arguments; instead, the geometric filtering is achieved through <a href="../framewise/#HCIToolbox.AnnulusView"><code>AnnulusView</code></a> and <a href="../framewise/#HCIToolbox.MultiAnnulusView"><code>MultiAnnulusView</code></a>. Parallactic angle thresholding is implemented in the <a href="../framewise/#ADI.Framewise"><code>Framewise</code></a> algorithm wrapper. I&#39;ve separated these techniques because they are fundamentally independent and because it greatly increases the composability of the algorithms.</li></ul><p>The biggest difference, though, is Julia&#39;s multiple-dispatch system and how that allows ADI.jl to <em>do more with less code</em>. For example, the <a href="../algorithms/greeds/#ADI.GreeDS"><code>GreeDS</code></a> algorithm was designed explicitly for <a href="../algorithms/pca/#ADI.PCA"><code>PCA</code></a>, but the formalism of it is more generic than that. Rather than hard-coding in PCA, the GreeDS algorithm was written generically, and Julia&#39;s multiple-dispatch  allows the use of, say, <a href="../algorithms/nmf/#ADI.NMF"><code>NMF</code></a> instead of PCA. By making the code <em>generic</em> and <em>modular</em>, ADI.jl enables rapid experimentation with different post-processing algorithms and techniques as well as minimizing the code required to implement a new algorithm and be able to fully use the ADI.jl API.</p><h2 id="Feature-comparison"><a class="docs-heading-anchor" href="#Feature-comparison">Feature comparison</a><a id="Feature-comparison-1"></a><a class="docs-heading-anchor-permalink" href="#Feature-comparison" title="Permalink"></a></h2><p>Some notable libraries for HCI tasks include <a href="https://github.com/vortex-exoplanet/VIP">VIP</a>, <a href="https://pyklip.readthedocs.io/en/latest/">pyKLIP</a>, and <a href="https://github.com/PynPoint/PynPoint">PynPoint</a>. A table of the feature sets of these packages alongside ADI.jl is presented below. In general VIP offers the most diversity in algorithms and their applications, but not all algorithms are as feature-complete as the PCA implementation. VIP also contains many useful utilities for pre-processing and a pipeline framework. pyKLIP primarily uses the PCA (KLIP) algorithm, but offers many forward modeling implementations. PynPoint has a highly modular pre-processing module that is focused on pipelines.</p><table><tr><th style="text-align: center">-</th><th style="text-align: center">Pre.</th><th style="text-align: center">Algs.</th><th style="text-align: center">Techs.</th><th style="text-align: center">D.M.</th><th style="text-align: center">F.M.</th></tr><tr><td style="text-align: center">ADI.jl</td><td style="text-align: center">✗</td><td style="text-align: center">median, PCA, NMF, fixed-point GreeDS</td><td style="text-align: center">Full-frame ADI/RDI, SDI (experimental), annular ADI*</td><td style="text-align: center">detection maps, STIM, SLIMask, contrast curve</td><td style="text-align: center">✗</td></tr><tr><td style="text-align: center">VIP</td><td style="text-align: center">✓</td><td style="text-align: center">median, LOCI, PCA, NMF, LLSG, ANDROMEDA, pairwise frame differencing</td><td style="text-align: center">Full-frame ADI/RDI, SDI, annular ADI/RDI*</td><td style="text-align: center">detection maps, blob detection, STIM, ROC, contrast curve</td><td style="text-align: center">NegFC</td></tr><tr><td style="text-align: center">pyKLIP</td><td style="text-align: center">✗</td><td style="text-align: center">PCA, NMF, weighted PCA</td><td style="text-align: center">Full-frame ADI/RDI, SDI, annular ADI/RDI</td><td style="text-align: center">detection maps, blob detection, contrast curve, cross-correlation</td><td style="text-align: center">KLIP-FM, Planet Evidence, matched filter (FMMF), spectrum fitting, DiskFM</td></tr><tr><td style="text-align: center">PynPoint</td><td style="text-align: center">✓</td><td style="text-align: center">median, PCA</td><td style="text-align: center">Full-frame ADI/RDI, SDI</td><td style="text-align: center">detection maps, contrast curve</td><td style="text-align: center">✗</td></tr></table><p><strong>Column labels:</strong> Pre-processing, Algorithms, Techniques, Detection Metrics, Forward Modeling.</p><p><em>Techniques marked with * indicate partial support, meaning that not all algorithms are supported.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../introduction/">« Introduction to HCI</a><a class="docs-footer-nextpage" href="../algorithms/classic/">Classic »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Saturday 16 January 2021 07:53">Saturday 16 January 2021</span>. Using Julia version 1.5.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
