<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Metrics · ADI.jl</title><link rel="canonical" href="https://juliahci.github.io/ADI.jl/metrics/"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">ADI.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../introduction/">Introduction to HCI</a></li><li><a class="tocitem" href="../gettingstarted/">Getting Started with ADI.jl</a></li><li><span class="tocitem">Algorithms</span><ul><li><a class="tocitem" href="../algorithms/classic/">Classic</a></li><li><a class="tocitem" href="../algorithms/pca/">PCA</a></li><li><a class="tocitem" href="../algorithms/nmf/">NMF</a></li><li><a class="tocitem" href="../algorithms/greeds/">GreeDS</a></li><li><a class="tocitem" href="../algorithms/api/">API/Reference</a></li></ul></li><li><a class="tocitem" href="../framewise/">Framewise</a></li><li><a class="tocitem" href="../sdi/">SDI</a></li><li class="is-active"><a class="tocitem" href>Metrics</a><ul class="internal"><li><a class="tocitem" href="#Detection-maps"><span>Detection maps</span></a></li><li><a class="tocitem" href="#Ensemble-methods"><span>Ensemble methods</span></a></li><li><a class="tocitem" href="#Throughput"><span>Throughput</span></a></li><li><a class="tocitem" href="#Contrast-curve"><span>Contrast curve</span></a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../examples/betapictoris/">ADI Reduction of <span>$\beta$</span> Pictoris</a></li><li><a class="tocitem" href="../examples/geometries/">Exploring spatial and temporal filtering</a></li></ul></li><li><a class="tocitem" href="../benchmarks/">Benchmarks</a></li><li><a class="tocitem" href="../api/">Index</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Metrics</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Metrics</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/juliahci/ADI.jl/blob/master/docs/src/metrics.md#L" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Metrics"><a class="docs-heading-anchor" href="#Metrics">Metrics</a><a id="Metrics-1"></a><a class="docs-heading-anchor-permalink" href="#Metrics" title="Permalink"></a></h1><ul><li><a href="#ADI.Metrics.contrast_curve"><code>ADI.Metrics.contrast_curve</code></a></li><li><a href="#ADI.Metrics.detectionmap"><code>ADI.Metrics.detectionmap</code></a></li><li><a href="#ADI.Metrics.estimate_starphot"><code>ADI.Metrics.estimate_starphot</code></a></li><li><a href="#ADI.Metrics.noise"><code>ADI.Metrics.noise</code></a></li><li><a href="#ADI.Metrics.significance"><code>ADI.Metrics.significance</code></a></li><li><a href="#ADI.Metrics.slimmap"><code>ADI.Metrics.slimmap</code></a></li><li><a href="#ADI.Metrics.snr"><code>ADI.Metrics.snr</code></a></li><li><a href="#ADI.Metrics.stim"><code>ADI.Metrics.stim</code></a></li><li><a href="#ADI.Metrics.stim_threshold"><code>ADI.Metrics.stim_threshold</code></a></li><li><a href="#ADI.Metrics.stimmap"><code>ADI.Metrics.stimmap</code></a></li><li><a href="#ADI.Metrics.subsample_contrast"><code>ADI.Metrics.subsample_contrast</code></a></li><li><a href="#ADI.Metrics.throughput"><code>ADI.Metrics.throughput</code></a></li></ul><article class="docstring"><header><a class="docstring-binding" id="ADI.Metrics" href="#ADI.Metrics"><code>ADI.Metrics</code></a> — <span class="docstring-category">Module</span></header><section><div><pre><code class="language-julia">ADI.Metrics</code></pre><p>This module provides code for analyzing the results from ADI in a way that is interpretable statistically. Some of the key functionalities are signal-to-noise, significance, the receiver operating characteristic, and the contrast curve.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/juliahci/ADI.jl/blob/cdd9b43192101f6cf41373733edcf9c399dfa3a1/src/metrics/Metrics.jl#LL1-L5">source</a></section></article><h2 id="Detection-maps"><a class="docs-heading-anchor" href="#Detection-maps">Detection maps</a><a id="Detection-maps-1"></a><a class="docs-heading-anchor-permalink" href="#Detection-maps" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="ADI.Metrics.detectionmap" href="#ADI.Metrics.detectionmap"><code>ADI.Metrics.detectionmap</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">detectionmap([method=snr], data, fwhm; fill=0)</code></pre><p>Parallel implementation of arbitrary detection mapping applied to each pixel in the input image. Any invalid values will be set to <code>fill</code>.</p><p>The following methods are provided in the <a href="#ADI.Metrics"><code>Metrics</code></a> module:</p><ul><li><a href="#ADI.Metrics.snr"><code>snr</code></a> - signal-to-noise ratio (S/N) using student-t statistics to account for small sample penalty.</li><li><a href="#ADI.Metrics.significance"><code>significance</code></a> - Gaussian signifance using student-t statistics to account for small samples penalty.</li><li><a href="#ADI.Metrics.noise"><code>noise</code></a> - Standard deviation of apertures in each annulus.</li></ul><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>This code is automatically multi-threaded, so be sure to set <code>JULIA_NUM_THREADS</code> before loading your runtime to take advantage of it!</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/juliahci/ADI.jl/blob/cdd9b43192101f6cf41373733edcf9c399dfa3a1/src/metrics/snr.jl#LL8-L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ADI.Metrics.snr" href="#ADI.Metrics.snr"><code>ADI.Metrics.snr</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">snr(data, position, fwhm)</code></pre><p>Calculate the signal to noise ratio (SNR, S/N) for a test point at <code>position</code> using apertures of diameter <code>fwhm</code> in a residual frame.</p><p>Uses the method of Mawet et al. 2014 which includes penalties for small sample statistics. These are encoded by using a student&#39;s t-test for calculating the SNR.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>SNR is not equivalent to significance, use <a href="#ADI.Metrics.significance"><code>significance</code></a> instead</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/juliahci/ADI.jl/blob/cdd9b43192101f6cf41373733edcf9c399dfa3a1/src/metrics/snr.jl#LL38-L47">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ADI.Metrics.significance" href="#ADI.Metrics.significance"><code>ADI.Metrics.significance</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">significance(data, position, fwhm)</code></pre><p>Calculates the Gaussian significance from the signal-to-noise ratio (SNR, S/N) for a test point at <code>position</code> using apertures of diameter <code>fwhm</code> in a residual frame.</p><p>The Gaussian signifiance is calculated from converting the SNR confidence limit from a student t distribution to a Gaussian via</p><p><span>$\text{sig}(\text{SNR}) = \Phi^{-1}\left[\int_0^\text{SNR}{t_\nu(x)dx}\right]$</span></p><p>where the degrees of freedom <span>$\nu$</span> is given as <span>$2\pi r / \Gamma - 2$</span> where r is the radial distance of each pixel from the center of the frame.</p><p><strong>See Also</strong></p><p><a href="#ADI.Metrics.snr"><code>snr</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/juliahci/ADI.jl/blob/cdd9b43192101f6cf41373733edcf9c399dfa3a1/src/metrics/snr.jl#LL80-L93">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ADI.Metrics.noise" href="#ADI.Metrics.noise"><code>ADI.Metrics.noise</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">noise(data, position, fwhm)</code></pre><p>Calculate the statistical noise for a test point at <code>position</code> using apertures of diameter <code>fwhm</code> in a residual frame.</p><p>Uses the standard deviation of the apertures in the entire annulus. This is distinct from the <a href="#ADI.Metrics.snr"><code>snr</code></a> noise calculation, which defines a confidence interval using student-t statistics. This means you cannot simply create a noise map and divide it from the signal to create an equivalent S/N map.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/juliahci/ADI.jl/blob/cdd9b43192101f6cf41373733edcf9c399dfa3a1/src/metrics/snr.jl#LL115-L121">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ADI.Metrics.stimmap" href="#ADI.Metrics.stimmap"><code>ADI.Metrics.stimmap</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">stimmap(residuals, angles)</code></pre><p>Calculate the standardized trajectory intensity mean (STIM) map. The inputs are a cube of residuals and the corresponding parallactic angles.</p><p>This method seeks to improve upon the typical student-t S/N tests (<a href="#ADI.Metrics.snr"><code>snr</code></a>, <a href="#ADI.Metrics.significance"><code>significance</code></a>) by calculating statistics in the temporal domain instead of the spatial domain. This is why the full residual cube is required rather than a reduced frame. </p><p>In particular, the STIM map is robust to detections with multiple objects or extended sources within the same annuli, which results in very high noise estimates using spatial methods. The STIM map also performs better at small angular separations, since the temporal domain has no limitations from limited resolution elements.</p><p><em>Pairet et al. 2019</em> derives a detection threshold of <code>τ = 0.5</code> for the STIM map. The detection threshold can be calculated for a specific dataset using <a href="#ADI.Metrics.stim_threshold"><code>stim_threshold</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia">julia&gt; cube, angles = # load data

julia&gt; S = subtract(PCA(10), cube, angles);

julia&gt; sm = stimmap(S, angles);</code></pre><p><strong>References</strong></p><ol><li><a href="http://adsabs.harvard.edu/abs/2019MNRAS.487.2262P">Pairet et al. 2019</a> &quot;STIM map: detection map for exoplanets imaging beyond asymptotic Gaussian residual speckle noise&quot;</li></ol><p><strong>See Also</strong></p><p><a href="#ADI.Metrics.stim_threshold"><code>stim_threshold</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/juliahci/ADI.jl/blob/cdd9b43192101f6cf41373733edcf9c399dfa3a1/src/metrics/stim.jl#LL1-L27">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ADI.Metrics.stim_threshold" href="#ADI.Metrics.stim_threshold"><code>ADI.Metrics.stim_threshold</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">stim_threshold([stimmap, ] residuals, angles)</code></pre><p>Calculate the detection threshold for the standardized trajectory intensity mean (STIM) map. This method uses the same residual cube as <a href="#ADI.Metrics.stimmap"><code>stimmap</code></a> but adds an additional step of estimating the residual noise by derotating the residuals with the <em>opposite</em> parallactic angles.</p><p>If the STIM map has already been calculated, it can be passed in, otherwise it will be calculated in addition to the noise map. Note this will not return the STIM map, only the threshold.</p><p>The threshold is derived in section 5.1 of <em>Pairet et al. 2019</em> as the ratio of the number of pixels above the approximated noise map. They found a value of <code>τ = 0.5</code> to be typical.</p><p><strong>Examples</strong></p><pre><code class="language-julia">julia&gt; cube, angles = # load data

julia&gt; S = subtract(PCA(10), cube, angles);

julia&gt; sm = stimmap(S, angles);

julia&gt; τ = stim_threshold(sm, S, angles);</code></pre><p><strong>References</strong></p><ol><li><a href="http://adsabs.harvard.edu/abs/2019MNRAS.487.2262P">Pairet et al. 2019</a> &quot;STIM map: detection map for exoplanets imaging beyond asymptotic Gaussian residual speckle noise&quot;</li></ol><p><strong>See Also</strong></p><p><a href="#ADI.Metrics.stimmap"><code>stimmap</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/juliahci/ADI.jl/blob/cdd9b43192101f6cf41373733edcf9c399dfa3a1/src/metrics/stim.jl#LL32-L59">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ADI.Metrics.stim" href="#ADI.Metrics.stim"><code>ADI.Metrics.stim</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">Metrics.stim(cube; dims)</code></pre><p>Calculates the STIM map of a derotated cube along the given <code>dims</code>. <code>dims</code> should correspond to the temporal axis of the cube. The STIM statistic is the slice mean divided by the slice standard deviation. Invalid values will become 0.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/juliahci/ADI.jl/blob/cdd9b43192101f6cf41373733edcf9c399dfa3a1/src/metrics/stim.jl#LL76-L80">source</a></section></article><h2 id="Ensemble-methods"><a class="docs-heading-anchor" href="#Ensemble-methods">Ensemble methods</a><a id="Ensemble-methods-1"></a><a class="docs-heading-anchor-permalink" href="#Ensemble-methods" title="Permalink"></a></h2><p>The following methods utilize the results of multiple ADI reductions, in some form.</p><article class="docstring"><header><a class="docstring-binding" id="ADI.Metrics.slimmap" href="#ADI.Metrics.slimmap"><code>ADI.Metrics.slimmap</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">slimmap(residuals, angles; N)
slimmap(stim_maps; N)</code></pre><p>Calculate the STIM largest intensity mask (SLIMask) map. This is an ensemble method which averages the STIM maps for multiple residual cubes. In addition to computing this average, for each STIM map all but the brightest <code>N</code> pixels will be masked out and eventaully averaged to create the SLIMask.</p><p><code>N</code> should represent a cutoff for the number of expected companions. For example, if the FWHM of the companion signal is 5 pixels, then the area under the fwhm is ~20 pixels. If I want to probe the brightest 4 potential companions, I would mask all but the <code>N = 20 * 4 = 80</code> brightest pixels.</p><p>Both the average STIM map and the SLIMask will be returned, and the two can be multiplied together to produce the SLIMask-STIM map. This achieves two things: first, the masking makes most of the pixels 0, providing better visual contrast in the map, and second, by averaging the mask, pixels which are not consistently in the brightest <code>N</code> for each STIM map will have lower probabilities in the corresponding SLIMask-STIM map.</p><p><strong>Examples</strong></p><p>This example recreates the analysis shown in Pairet, B. (2020) where the SLIM map is computed with the ensemble of residual cubes produced by increasing ranks of PCA subtraction.</p><pre><code class="language-julia">julia&gt; cube, angles = # load data

julia&gt; algs = PCA.(5:25);

julia&gt; residual_cubes = subtract.(algs, Ref(cube));

julia&gt; stim_av, slimmask = slimmap(residual_cubes, angles; N=100);

julia&gt; slim_prob_map = stim_av .* slimmask;</code></pre><p><strong>References</strong></p><ol><li><a href="https://dial.uclouvain.be/pr/boreal/object/boreal:240621">Pairet, B. 2020</a> &quot;Signal processing methods for high-contrast observations of planetary systems&quot;</li></ol><p><strong>See also</strong></p><p><a href="#ADI.Metrics.stimmap"><code>stimmap</code></a>, <a href="#ADI.Metrics.stim"><code>stim</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/juliahci/ADI.jl/blob/cdd9b43192101f6cf41373733edcf9c399dfa3a1/src/metrics/ensemble.jl#LL2-L35">source</a></section></article><h2 id="Throughput"><a class="docs-heading-anchor" href="#Throughput">Throughput</a><a id="Throughput-1"></a><a class="docs-heading-anchor-permalink" href="#Throughput" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="ADI.Metrics.throughput" href="#ADI.Metrics.throughput"><code>ADI.Metrics.throughput</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">throughput(alg, cube, angles, psf;
           fwhm, nbranch=1, theta=0, inner_rad=1,
           fc_rad_sep=3, snr=100, kwargs...)</code></pre><p>Calculate the throughput of <code>alg</code> by injecting fake companions into <code>cube</code> and measuring the relative photometry of each companion in the reduced frame. The photometry is measured using a circular aperture with a diameter matching the <code>fwhm</code>. Any additional <code>kwargs</code> will be passed to <code>alg</code> when it is called.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>nbranch</code> - number of azimuthal branches to use</li><li><code>theta</code> - position angle of initial branch</li><li><code>inner_rad</code> - position of innermost planet in FWHM</li><li><code>fc_rad_sep</code> - the separation between planets in FWHM for a single reduction</li><li><code>snr</code> - the target signal to noise ratio of the injected planets</li><li><code>reduced_empty</code> - the collapsed residual frame for estimating the noise. Will process using <code>alg</code> if not provided.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/juliahci/ADI.jl/blob/cdd9b43192101f6cf41373733edcf9c399dfa3a1/src/metrics/contrast.jl#LL193-L207">source</a></section><section><div><pre><code class="language-none">throughput(alg, cube, angles, psf, position;
           fwhm, snr=100, reduced_empty=nothing,
           verbose=true, kwargs...)</code></pre><p>Calculate the throughput of <code>alg</code> by injecting <code>psf</code> into <code>cube</code> at the given <code>position</code> and measuring the relative photometry of the companion in the reduced frame. The photometry is measured using a circular aperture with a diameter matching the <code>fwhm</code>. Any additional <code>kwargs</code> will be passed to <code>alg</code> when it is called.</p><p>If <code>position</code> is a tuple or a vector, it will be parsed as the cartesian coordinate <code>(x, y)</code>. If <code>position</code> is a <code>CoordinateTransformations.Polar</code> it will be parsed as polar coordinates from the center of the cube. Note the <code>Polar</code> type expects angles in radians.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>fwhm</code> - the full width at half-maximum</li><li><code>snr</code> - the target signal to noise ratio of the injected planets</li><li><code>reduced_empty</code> - the collapsed residual frame for estimating the noise. Will process using <code>alg</code> if not provided.</li><li><code>verbose</code> - show informative messages during process</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/juliahci/ADI.jl/blob/cdd9b43192101f6cf41373733edcf9c399dfa3a1/src/metrics/contrast.jl#LL273-L287">source</a></section></article><h2 id="Contrast-curve"><a class="docs-heading-anchor" href="#Contrast-curve">Contrast curve</a><a id="Contrast-curve-1"></a><a class="docs-heading-anchor-permalink" href="#Contrast-curve" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="ADI.Metrics.contrast_curve" href="#ADI.Metrics.contrast_curve"><code>ADI.Metrics.contrast_curve</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">contrast_curve(alg, cube, angles, psf;
               fwhm, sigma=5, nbranch=1, theta=0, inner_rad=1,
               starphot=Metrics.estimate_starphot(cube, fwhm),
               fc_rad_sep=3, snr=100, k=2, smooth=true,
               subsample=true, kwargs...)</code></pre><p>Calculate the throughput-calibrated contrast. This first processes the algorithmic <a href="#ADI.Metrics.throughput"><code>throughput</code></a> by injecting instances of <code>psf</code> into <code>cube</code>. These are processed through <code>alg</code> and the ratio of the recovered flux to the injected flux is calculated. These companions are injected in resolution elements across the frame, which can be changed via the various keyword arguments.</p><p>The throughput can only be calculated for discrete resolution elements, but we typically want a much smoother curve. To accomplish this, we measure the noise (the standard deviation of all resolution elements in an annulus at a given radius) for every pixel in increasing radii. We then interpolate the throughput to this grid and return the subsampled curves.</p><p><strong>Returned Fields</strong></p><ul><li><code>distance</code> - The radial distance (in pixels) for each measurement</li><li><code>contrast</code> - The Gaussian sensitivity</li><li><code>contrast_corr</code> - The Student-t sensitivity</li><li><code>noise</code> - The noise measured for each distance</li><li><code>throughput</code> - The throughput measured for each distance.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>sigma</code> - The confidence limit in terms of Gaussian standard deviations</li><li><code>starphot</code> - The flux of the star. By default calculates the flux in the central core.</li></ul><p><strong>Injection Options</strong> (See also <a href="#ADI.Metrics.throughput"><code>throughput</code></a>)</p><ul><li><code>nbranch</code> - number of azimuthal branches to use</li><li><code>theta</code> - position angle of initial branch</li><li><code>inner_rad</code> - position of innermost planet in FWHM</li><li><code>fc_rad_sep</code> - the separation between planets in FWHM for a single reduction</li><li><code>snr</code> - the target signal to noise ratio of the injected planets</li></ul><p><strong>Subsampling Options</strong> (See also <a href="#ADI.Metrics.subsample_contrast"><code>Metrics.subsample_contrast</code></a>)</p><ul><li><code>subsample</code> - If true, subsamples the throughput measurements to increase density of curve</li><li><code>k</code> - The order of the BSpline used for subsampling the throughput</li><li><code>smooth</code> - If true, will smooth the subsampled noise measurements with a 2nd order Savitzky-Golay filter</li></ul><p>Any additional <code>kwargs</code> will be passed to <code>alg</code> when it is called.</p><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>If you prefer a tabular format, simply pipe the output of this function into any type supporting the Tables.jl interface, e.g.</p><pre><code class="language-none">contrast_curve(alg, cube, angles, psf; fwhm=fwhm) |&gt; DataFrame</code></pre></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/juliahci/ADI.jl/blob/cdd9b43192101f6cf41373733edcf9c399dfa3a1/src/metrics/contrast.jl#LL10-L49">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ADI.Metrics.subsample_contrast" href="#ADI.Metrics.subsample_contrast"><code>ADI.Metrics.subsample_contrast</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">Metrics.subsample_contrast(empty_frame, distance, throughput;
                           fwhm, starphot, sigma=5, inner_rad=1,
                           theta=0, smooth=true, k=2)</code></pre><p>Helper function to subsample and smooth a contrast curve.</p><p>Contrast curves, by definition, are calculated with discrete resolution elements. This can cause contrast curves to have very few points instead of appearing as a continuously measured statistic across the pixels. We alleviate this by sub-sampling the throughput (via BSpline interpolation) across each pixel (instead of each resolution element).</p><p>The noise can be found efficiently enough, so rather than interpolate we measure the noise in annuli of width <code>fwhm</code> increasing in distance by 1 pixel. We measure this noise in <code>empty_frame</code>, which should be a 2D reduced ADI frame.</p><p>The noise measurements can be noisy, so a 2nd order Savitzky-Golay filter can be applied via <code>smooth</code>. This fits a quadratic polynomial over a window of <code>fwhm/2</code> points together to reduce high-frequency jitter.</p><p><strong>Examples</strong></p><p>Here is an example which calculates the exact contrast curve in addition to a subsampled curve without re-calculating the throughput.</p><pre><code class="language-julia">cube, angles, psf = # load data

alg = PCA(10)
cc = contrast_curve(alg, cube, angles, psf; fwhm=8.4, subsample=false)
reduced_empty = alg(cube, angles)
sp = Metrics.estimate_starphot(cube, 8.4)
cc_sub = Metrics.subsample_contrast(reduced_empty, cc.distance, cc.throughput;
                                    fwhm=8.4, starphot=sp)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/juliahci/ADI.jl/blob/cdd9b43192101f6cf41373733edcf9c399dfa3a1/src/metrics/contrast.jl#LL96-L123">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ADI.Metrics.estimate_starphot" href="#ADI.Metrics.estimate_starphot"><code>ADI.Metrics.estimate_starphot</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">Metrics.estimate_starphot(cube, fwhm)
Metrics.estimate_starphot(frame, fwhm)</code></pre><p>Simple utility to estimate the stellar photometry by placing a circular aperture with <code>fwhm</code> diameter in the center of the <code>frame</code>. If a cube is provided, first the median frame will be found.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/juliahci/ADI.jl/blob/cdd9b43192101f6cf41373733edcf9c399dfa3a1/src/metrics/contrast.jl#LL180-L185">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../sdi/">« SDI</a><a class="docs-footer-nextpage" href="../examples/betapictoris/">ADI Reduction of <span>$\beta$</span> Pictoris »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Tuesday 16 March 2021 21:14">Tuesday 16 March 2021</span>. Using Julia version 1.5.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
