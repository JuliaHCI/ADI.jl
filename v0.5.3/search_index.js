var documenterSearchIndex = {"docs":
[{"location":"sdi/#SDI","page":"SDI","title":"SDI","text":"","category":"section"},{"location":"sdi/","page":"SDI","title":"SDI","text":"warning: Warning\nSDI should be considered very experimental.","category":"page"},{"location":"sdi/","page":"SDI","title":"SDI","text":"ADI.SDIAlgorithm","category":"page"},{"location":"sdi/#ADI.SDIAlgorithm","page":"SDI","title":"ADI.SDIAlgorithm","text":"ADI.SDIAlgorithm <: ADI.ADIAlgorithm\n\nSpectral differential imaging (SDI) algorithms. These work on 4-D SDI tensors. To use these algorithms, simply treat them like functions\n\n(::SDIAlgorithm)(data::AbstractArray{T,4}, angles, scales; kwargs...)\n(::SDIAlgorithm)(data::AbstractArray{T,4}, angles, data_ref, scales; kwargs...)\n\nThe data is expected to be laid out in (nλ, nf, ny, nx) format, so you may need to permutedims before processing the data. The scales correspond to the relative wavelength scales for each spectrum, and can be retrieved with HCIToolbox.scale_list.\n\nAlgorithms\n\nThe current SDI implementations are\n\nSingleSDI\nDoubleSDI\nSliceSDI\n\n\n\n\n\n","category":"type"},{"location":"sdi/#API/Reference","page":"SDI","title":"API/Reference","text":"","category":"section"},{"location":"sdi/","page":"SDI","title":"SDI","text":"SingleSDI\nDoubleSDI\nSliceSDI","category":"page"},{"location":"sdi/#ADI.SingleSDI","page":"SDI","title":"ADI.SingleSDI","text":"SingleSDI(alg)\n\nA wrapper algorithm for spectral differential imaging (SDI) data reduced in a single pass. This means that each channel will be scaled and then concatenated together, so an SDI tensor (nλ, nf, y, x) becomes a stack (nλ * nf, y, x) which is processed by the underlying alg like ADI data.\n\ntip: Tip\nSingleSDI is the default SDI mode. This means instead of writingSingleSDI(PCA(15))(data, angles, scales)you can just writePCA(15)(data, angles, scales)\n\n\n\n\n\n","category":"type"},{"location":"sdi/#ADI.DoubleSDI","page":"SDI","title":"ADI.DoubleSDI","text":"DoubleSDI(alg)\nDoubleSDI(alg_spec, alg_temp)\n\nA wrapper algorithm for spectral differential imaging (SDI) data reduced in two passes. The first pass uses alg_spec to reduce each spectral cube slice in the SDI tensor. Then, the spectral residual frames will be reduced using alg_temp, which will include the derotation and final combination.\n\nThe difference between DoubleSDI and SliceSDI is that DoubleSDI does its first pass in the spectral slice, effectively collapsing the slice before performing ADI on the residual cube. SliceSDI does its first pass in the temporal slice, collapsing it first before performing ADI on the residual cube.\n\nExamples\n\njulia> data, angles, scales = # load data...\n\n# Median subtraction for each spectral slice,\n# GreeDS{PCA} subtraction on spectral residual cube\njulia> res = DoubleSDI(Median(), GreeDS(15))(data, angles, scales)\n\n\n\n\n\n","category":"type"},{"location":"sdi/#ADI.SliceSDI","page":"SDI","title":"ADI.SliceSDI","text":"SliceSDI(alg)\nSliceSDI(alg_spec, alg_temp)\n\nA wrapper algorithm for spectral differential imaging (SDI) data reduced in two passes. The first pass uses alg_temp to reduce each temporal cube slice in the SDI tensor. These residuals will be rescaled and stacked into a new cube. Then, the temporal residual frames will be reduced using alg_spec, which will include the derotation and final combination.\n\nThe difference between SliceSDI and DoubleSDI is that DoubleSDI does its first pass in the spectral slice, effectively collapsing the slice before performing ADI on the residual cube. SliceSDI does its first pass in the temporal slice, collapsing it first before performing ADI on the residual cube.\n\nExamples\n\njulia> data, angles, scales = # load data...\n\n# Median subtraction for each spectral slice,\n# GreeDS{PCA} subtraction on spectral residual cube\njulia> res = SliceSDI(Median(), GreeDS(15))(data, angles, scales)\n\n\n\n\n\n","category":"type"},{"location":"benchmarks/#Benchmarks","page":"Benchmarks","title":"Benchmarks","text":"","category":"section"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"The large scale image-processing required for ADI algorithms can lead to concerns about runtime efficiency. To this end, ADI.jl (and the associated JuliaHCI packages) are developed with performance in mind. These packages do not aim to be as fast as possible; rather they focus on being as fast as is convenient (for the users and the devs).","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"The Vortex Imaging Pipeline (VIP) is the inspiration for ADI.jl. It is one of the major Python HCI packages and it offers many more features than ADI.jl. Some of the common uses for both packages include full-frame ADI processing, S/N maps, and contrast curves.","category":"page"},{"location":"benchmarks/#System/Setup-Information","page":"Benchmarks","title":"System/Setup Information","text":"","category":"section"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"The benchmarks here can be found in the bench/ folder organized into Julia files. The benchmarks utilize BenchmarkTools.jl, PyCall.jl with virtualenv, and CSV.jl for accuracy, reproducibility, and organization.","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"Julia Version 1.5.0\nCommit 96786e22cc (2020-08-01 23:44 UTC)\nPlatform Info:\n  OS: macOS (x86_64-apple-darwin18.7.0)\n  CPU: Intel(R) Core(TM) i5-8259U CPU @ 2.30GHz\n  WORD_SIZE: 64\n  LIBM: libopenlibm\n  LLVM: libLLVM-9.0.1 (ORCJIT, skylake)\nEnvironment:\n  JULIA_NUM_THREADS = 4","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"For the python code, there is a requirements.txt file in bench/. To reproduce this environment, (optionally) activate a virtual environment then install from the requirements file.","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"(venv) $ pip install -r requirements.txt","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"For reproducibility, there is a Manifest.toml file in bench/. To reproduce this environment, first activate it, then instantiate it","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"$ julia --project=bench -e 'using Pkg; Pkg.instantiate()'","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"warning: PyCall.jl and virtual environments\nThe interface between Julia and python is handled by PyCall.jl. When using a virtual environment, PyCall may not use the correct python library. Before running the benchmarks, please read this reference.","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"tip: Multi-threading\nSome of the image-processing methods in ADI.jl and HCIToolbox.jl are multi-threaded, and will lead to a noticable difference in some benchmarks. To take advantage of this, set the environment variable JULIA_NUM_THREADS before starting your runtime. Multi-Threading documentation.","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"using CSV\nusing DataFrames\nusing StatsPlots\nbenchdir(args...) = joinpath(\"..\", \"..\" ,\"bench\", args...);","category":"page"},{"location":"benchmarks/#ADI-Reduction","page":"Benchmarks","title":"ADI Reduction","text":"","category":"section"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"These benchmarks show the duration to fully reduce ADI data for various algorithms. The data used are beta Pictoris and HR8799 from HCIDatasets.jl.","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"adi_data = CSV.File(benchdir(\"adi_benchmarks.csv\")) |> DataFrame |> sort!\ncube_labels = @. ifelse(adi_data.N == 622261, \"Beta Pictoris\", \"HR8799\")\ninsertcols!(adi_data, 4, :cube => cube_labels)\nadi_groups = groupby(adi_data, :framework)","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"cube_groups = groupby(adi_data, :cube)\nplot(\n    @df(cube_groups[1], groupedbar(:alg, :time, group=:framework, yscale=:log10)),\n    @df(cube_groups[2], groupedbar(:alg, :time, group=:framework)),\n    size=(700, 350),\n    leg=:topleft,\n    ylabel=\"time (s)\",\n    title=[\"Beta Pictoris\" \"HR8799\"]\n)","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"Please note the log-scale for the left figure.","category":"page"},{"location":"benchmarks/#Detection-Maps","page":"Benchmarks","title":"Detection Maps","text":"","category":"section"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"This benchmark measures the duration to produce a signal-to-noise ratio (S/N) map. Rather than test exact cubes, these benchmarks test randomly generated frames of various sizes. The FWHM is fixed at 5.","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"snrmap_data = CSV.File(benchdir(\"snrmap_benchmarks.csv\")) |> DataFrame |> sort!\nsnrmap_groups = groupby(snrmap_data, :framework)","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"@df snrmap_data scatter(\n    :N,\n    :time,\n    group=:framework,\n    ms=6,\n    xlabel=\"number of pixels\",\n    ylabel=\"time (s)\"\n)","category":"page"},{"location":"benchmarks/#Contrast-Curves","page":"Benchmarks","title":"Contrast Curves","text":"","category":"section"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"Finally, this benchmark measures the duration to generate a contrast curve for analyzing the algorithmic throughput of an ADI algorithm. For both benchmarks 3 azimuthal branches are used for throughput injections and a FWHM of 8. A Gaussian PSF function is evaluated in a (21, 21) grid for the injections. The data used are beta Pictoris and HR8799 from HCIDatasets.jl.","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"contrast_data = CSV.File(benchdir(\"contrast_benchmarks.csv\")) |> DataFrame |> sort!\ncube_labels = @. ifelse(contrast_data.N == 622261, \"Beta Pictoris\", \"HR8799\")\ninsertcols!(contrast_data, 4, :cube => cube_labels)\ncontrast_groups = groupby(contrast_data, :framework)","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"@df contrast_data groupedbar(\n    :cube,\n    :time,\n    group=:framework,\n    leg=:topleft,\n    ylabel=\"time (s)\",\n    yscale=:log10,\n)","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"Please note the log-scale.","category":"page"},{"location":"algorithms/nmf/#nmf","page":"NMF","title":"NMF","text":"","category":"section"},{"location":"algorithms/nmf/#API/Reference","page":"NMF","title":"API/Reference","text":"","category":"section"},{"location":"algorithms/nmf/","page":"NMF","title":"NMF","text":"NMF","category":"page"},{"location":"algorithms/nmf/#ADI.NMF","page":"NMF","title":"ADI.NMF","text":"NMF(;ncomps=nothing) <: LinearAlgorithm\nNMF(ncomps)\n\nUse non-negative matrix factorization (NMF, NNMF) to form a non-negative, low-rank, and orthonormal basis of the input. The implementation of the underlying NMF is provided by NMF.jl. The implementation uses a non-negative SVD for initialization and a coordinate-descent solver to fit.\n\nIf ncomps is nothing, it will be set to the number of frames in the reference cube when processed.\n\nwarning: Non-negativity constraint\nNMF is not designed to fit negative values. This algorithm will warn you (but will not error) if a target or reference cube contains negative values. The output may seem reasonable, but it is not well-defined with respect to the NMF algorithm. To overcome this, rescaling the data by its minimum before processing is necessarytarget = cube .- minimum(cube)\nS = reconstruct(NMF(), target, angles)When doing full-frame reduction (e.g. NMF()(cube, angles)) this is handled automatically, so this constraint only applies to the lower-level API and methods which rely on those, such as GreeDS. In general, if you see warnings, heed them.\n\nImplements\n\ndecompose\n\nReferences\n\nRen et al. 2018 Non-negative Matrix Factorization: Robust Extraction of Extended Structures\n\n\n\n\n\n","category":"type"},{"location":"algorithms/pca/#pca","page":"PCA","title":"PCA","text":"","category":"section"},{"location":"algorithms/pca/#API/Reference","page":"PCA","title":"API/Reference","text":"","category":"section"},{"location":"algorithms/pca/","page":"PCA","title":"PCA","text":"PCA\nTPCA","category":"page"},{"location":"algorithms/pca/#ADI.PCA","page":"PCA","title":"ADI.PCA","text":"PCA(;ncomps=nothing, pratio=1) <: LinearAlgorithm\nPCA(ncomps; pratio=1)\n\nUse principal components analysis (PCA) to form a low-rank orthonormal basis of the input. Uses deterministic singular-value decomposition (SVD) to decompose data.\n\nIf ncomps is nothing, it will be set to the number of frames in the reference cube when processed.\n\nReferences\n\nSoummer, Pueyo, and Larkin (2012) \"Detection and Characterization of Exoplanets and Disks Using Projections on Karhunen-Loève Eigenimages\"\n\nImplements\n\ndecompose\n\n\n\n\n\n","category":"type"},{"location":"algorithms/pca/#ADI.TPCA","page":"PCA","title":"ADI.TPCA","text":"TPCA(;ncomps=nothing) <: LinearAlgorithm\nTPCA(ncomps; pratio=1)\n\nPerform principal components analysis (PCA) using truncated SVD (TSVD; provided by TSVD.jl) instead of deterministic SVD. This is often faster than PCA but is non-deterministic, so the results may be different.\n\nIf ncomps is nothing, it will be set to the number of frames in the reference cube when processed.\n\nImplements\n\ndecompose\n\nSee Also\n\nPCA, TSVD.tsvd\n\n\n\n\n\n","category":"type"},{"location":"gettingstarted/#gettingstarted","page":"Getting Started with ADI.jl","title":"Getting Started","text":"","category":"section"},{"location":"gettingstarted/","page":"Getting Started with ADI.jl","title":"Getting Started with ADI.jl","text":"Here is a quick-start guide for people familiar with ADI and experience using tools like VIP or pyKLIP. For installation and setup information, see the Installation and Setup section.","category":"page"},{"location":"gettingstarted/#Expected-Data-Formats","page":"Getting Started with ADI.jl","title":"Expected Data Formats","text":"","category":"section"},{"location":"gettingstarted/#ADI-Cube","page":"Getting Started with ADI.jl","title":"ADI Cube","text":"","category":"section"},{"location":"gettingstarted/","page":"Getting Started with ADI.jl","title":"Getting Started with ADI.jl","text":"For standard ADI data, we store the values in a 3-dimensional array, where the first dimension is temporal, and the remaining dimensions are pixel coordinates. This is how most ADI data are stored on disk (typically in FITS files) and allow specifying operations like a tensor. This cube should already be registered with the star in the center of the frames (note the center is only well-defined for odd-sized frames, even though even-sized frames will work fine).","category":"page"},{"location":"gettingstarted/#Parallactic-Angles","page":"Getting Started with ADI.jl","title":"Parallactic Angles","text":"","category":"section"},{"location":"gettingstarted/","page":"Getting Started with ADI.jl","title":"Getting Started with ADI.jl","text":"The parallactic angles should be stored as degrees in a vector. The parallactic angle X[i] will result in rotating frame i X[i] degrees counter-clockwise.","category":"page"},{"location":"gettingstarted/#SDI-Cube/Tensor","page":"Getting Started with ADI.jl","title":"SDI Cube/Tensor","text":"","category":"section"},{"location":"gettingstarted/","page":"Getting Started with ADI.jl","title":"Getting Started with ADI.jl","text":"For standard SDI data, we store the values in a 4-dimensional array, where the first dimension is spectral, the second is temporal, and the remaining dimensions are pixel coordinates. This is how some SDI data are stored on disk (typically in FITS files) and allow specifying operations like a tensor. For SDI data that is stored with the temporal axis first, the dimensions should be permuted before processing (see permutedims). This cube should also be registered with the star in the center of the frame.","category":"page"},{"location":"gettingstarted/","page":"Getting Started with ADI.jl","title":"Getting Started with ADI.jl","text":"In addition to the SDI tensor and parallactic angles, the list of wavelengths are required (for scaling speckles) and a spectral template can be used. To create a scale list from the wavelengths, use HCIToolbox.scale_list. Currently there is not support for spectral templates.","category":"page"},{"location":"gettingstarted/#Algorithms","page":"Getting Started with ADI.jl","title":"Algorithms","text":"","category":"section"},{"location":"gettingstarted/","page":"Getting Started with ADI.jl","title":"Getting Started with ADI.jl","text":"The following algorithms are implemented:","category":"page"},{"location":"gettingstarted/","page":"Getting Started with ADI.jl","title":"Getting Started with ADI.jl","text":"Median Subtraction\nPCA\nNMF\nGreeDS","category":"page"},{"location":"gettingstarted/#Processing-Patterns","page":"Getting Started with ADI.jl","title":"Processing Patterns","text":"","category":"section"},{"location":"gettingstarted/#Full-Frame-ADI-Reduction","page":"Getting Started with ADI.jl","title":"Full Frame ADI Reduction","text":"","category":"section"},{"location":"gettingstarted/","page":"Getting Started with ADI.jl","title":"Getting Started with ADI.jl","text":"Given an algorithm alg, we can fully process ADI data by calling alg like a function","category":"page"},{"location":"gettingstarted/","page":"Getting Started with ADI.jl","title":"Getting Started with ADI.jl","text":"julia> using ADI\n\njulia> alg = PCA(ncomps=5)\n\njulia> resid = alg(cube, angles)","category":"page"},{"location":"gettingstarted/#Full-Frame-RDI-Reduction","page":"Getting Started with ADI.jl","title":"Full Frame RDI Reduction","text":"","category":"section"},{"location":"gettingstarted/","page":"Getting Started with ADI.jl","title":"Getting Started with ADI.jl","text":"The only difference here is the inclusion of a reference cube.","category":"page"},{"location":"gettingstarted/","page":"Getting Started with ADI.jl","title":"Getting Started with ADI.jl","text":"julia> alg = PCA(ncomps=5)\n\njulia> resid = alg(cube, angles, cube_ref)","category":"page"},{"location":"gettingstarted/#Reduction-Process","page":"Getting Started with ADI.jl","title":"Reduction Process","text":"","category":"section"},{"location":"gettingstarted/","page":"Getting Started with ADI.jl","title":"Getting Started with ADI.jl","text":"The process for producing the flat, residual frame follows this general workflow","category":"page"},{"location":"gettingstarted/","page":"Getting Started with ADI.jl","title":"Getting Started with ADI.jl","text":"Create a cube of the speckle approximation, S\nSubtract S from the data cube to create the residual cube R\nDerotate R frame-by-frame according to the parallactic angle\nCollapse the derotated R","category":"page"},{"location":"gettingstarted/","page":"Getting Started with ADI.jl","title":"Getting Started with ADI.jl","text":"In ADI.jl this process looks like this:","category":"page"},{"location":"gettingstarted/","page":"Getting Started with ADI.jl","title":"Getting Started with ADI.jl","text":"cube, angles = # load data\nS = reconstruct(PCA(10), cube, angles)\nR = cube .- S\nR_derotate = derotate(R, angles)\nresid = collapse(R_derotate)\n# or, more succinctly\nresid = collapse(R, angles)","category":"page"},{"location":"gettingstarted/","page":"Getting Started with ADI.jl","title":"Getting Started with ADI.jl","text":"Notice how the only part of this specific to the algorithm is reconstruct? This lets us have the super-compact functional form from above without having to copy the common code for each algorithm.","category":"page"},{"location":"gettingstarted/#Decomposition","page":"Getting Started with ADI.jl","title":"Decomposition","text":"","category":"section"},{"location":"gettingstarted/","page":"Getting Started with ADI.jl","title":"Getting Started with ADI.jl","text":"For certain types of ADI algorithms, a convenient linear form is used for the speckle approximation","category":"page"},{"location":"gettingstarted/","page":"Getting Started with ADI.jl","title":"Getting Started with ADI.jl","text":"mathbfS approx mathbfw cdot mathbfA","category":"page"},{"location":"gettingstarted/","page":"Getting Started with ADI.jl","title":"Getting Started with ADI.jl","text":"where mathbfS represents the speckle reconstruction in a flattened matrix (where each row is an unrolled image), mathbfA represents a linear basis (again as a matrix with each row corresponding the a basis image), and mathbfw represents the projection of the target data onto the linear basis (the weights of an observation). mathbfS is what is used for subtracting from the target in typical ADI.","category":"page"},{"location":"gettingstarted/","page":"Getting Started with ADI.jl","title":"Getting Started with ADI.jl","text":"Algorithms which share this attribute share the abstract type ADI.LinearAlgorithm, and we can retrieve these two matrices via decompose. Note that all of these terms treat the images as row vectors; to reshape back to a cube, use HCIToolbox.expand (note: HCIToolbox.jl is re-exported by ADI.jl, so all its features are usable without importing it directly).","category":"page"},{"location":"gettingstarted/","page":"Getting Started with ADI.jl","title":"Getting Started with ADI.jl","text":"using ADI\ncube, angles = # load data\nA, w = decompose(PCA(10), cube, angles)\nS = reconstruct(PCA(10), A, w)\n@assert S ≈ w * A\n@assert size(expand(S)) == size(cube)","category":"page"},{"location":"gettingstarted/#Comparison-to-VIP","page":"Getting Started with ADI.jl","title":"Comparison to VIP","text":"","category":"section"},{"location":"gettingstarted/","page":"Getting Started with ADI.jl","title":"Getting Started with ADI.jl","text":"ADI.jl took a lot of ideas from VIP and expanded them using the power of Julia. To begin with, Julia typically has smaller and more self-contained packages, so most of the basic image-processing that is used here is actually written in the HCIToolbox.jl package. In the future, I have plans to incorporate forward-modeling distributions in Firefly.jl, which currently is an active research project.","category":"page"},{"location":"gettingstarted/","page":"Getting Started with ADI.jl","title":"Getting Started with ADI.jl","text":"Some technical distinctions to VIP","category":"page"},{"location":"gettingstarted/","page":"Getting Started with ADI.jl","title":"Getting Started with ADI.jl","text":"Julia is 1-indexed. This means all the positions for apertures, bounds, images, etc. start at 1. This is distinct from 0-based indexing in python, but is equivalent to the indexing in DS9 and IRAF.\nJulia's std uses the sample statistic (n-1 degrees of freedom) while numpy's std uses the population statistic (n degrees of freedom). This may cause very slight differences in measurements that rely on this.\nAperture mapping - many of the Metrics are derived by measuring statistics in an annulus of apertures. In VIP, this ring is not equally distributed- the angle between apertures is based on the exact number of apertures rather than the integral number of apertures that are actually measured. In ADI.jl the angle between apertures is evenly distributed. The same number of pixels are discarded in both packages, but in VIP they all end up in the same region of the image (see this figure).\nCollapsing - by default VIP collapses a cube by derotating it then finding the median frame. In ADI.jl, the default collapse method is a weighted sum using the inverse of the temporal variance for weighting. This is documented in HCIToolbox.collapse and can be overridden by passing the keyword argument method=median or whichever statistical funciton you want to use.","category":"page"},{"location":"gettingstarted/","page":"Getting Started with ADI.jl","title":"Getting Started with ADI.jl","text":"The biggest difference, though, is Julia's multiple-dispatch system and how that allows ADI.jl to do more with less code. For example, the GreeDS algorithm was designed explicitly for PCA, but the formalism of it is more generic than that. Rather than hard-coding in PCA, the GreeDS algorithm was written generically, and Julia's multiple-dispatch  allows the use of, say, NMF instead of PCA. By making the code generic and modular, ADI.jl enables rapid experimentation with different post-processing algorithms and techniques as well as minimizing the code required to implement a new algorithm and be able to fully use the ADI.jl API.","category":"page"},{"location":"gettingstarted/#Feature-comparison","page":"Getting Started with ADI.jl","title":"Feature comparison","text":"","category":"section"},{"location":"gettingstarted/","page":"Getting Started with ADI.jl","title":"Getting Started with ADI.jl","text":"Some notable libraries for HCI tasks include VIP, pyKLIP, and PynPoint. A table of the feature sets of these packages alongside ADI.jl is presented below. In general VIP offers the most diversity in algorithms and their applications, but not all algorithms are as feature-complete as the PCA implementation. VIP also contains many useful utilities for pre-processing and a pipeline framework. pyKLIP primarily uses the PCA (KLIP) algorithm, but offers many forward modeling implementations. PynPoint has a highly modular pre-processing module that is focused on pipelines.","category":"page"},{"location":"gettingstarted/","page":"Getting Started with ADI.jl","title":"Getting Started with ADI.jl","text":"- Pre. Algs. Techs. D.M. F.M.\nADI.jl ✗ median, PCA, NMF, fixed-point GreeDS Full-frame ADI/RDI, SDI (experimental) detection maps, STIM, contrast curve ✗\nVIP ✓ median, LOCI, PCA, NMF, LLSG, ANDROMEDA, pairwise frame differencing Full-frame ADI/RDI, SDI, annular ADI/RDI* detection maps, blob detection, STIM, ROC, contrast curve NegFC\npyKLIP ✗ PCA, NMF, weighted PCA Full-frame ADI/RDI, SDI, annular ADI/RDI detection maps, blob detection, contrast curve, cross-correlation KLIP-FM, Planet Evidence, matched filter (FMMF), spectrum fitting, DiskFM\nPynPoint ✓ median, PCA Full-frame ADI/RDI, SDI detection maps, contrast curve ✗","category":"page"},{"location":"gettingstarted/","page":"Getting Started with ADI.jl","title":"Getting Started with ADI.jl","text":"Column labels: Pre-processing, Algorithms, Techniques, Detection Metrics, Forward Modeling.","category":"page"},{"location":"gettingstarted/","page":"Getting Started with ADI.jl","title":"Getting Started with ADI.jl","text":"Techniques marked with * indicate partial support, meaning that not all algorithms are supported.","category":"page"},{"location":"algorithms/median/#med","page":"Median","title":"Median","text":"","category":"section"},{"location":"algorithms/median/#API/Reference","page":"Median","title":"API/Reference","text":"","category":"section"},{"location":"algorithms/median/","page":"Median","title":"Median","text":"Median","category":"page"},{"location":"algorithms/median/#ADI.Median","page":"Median","title":"ADI.Median","text":"Median()\n\nClassic PSF subtraction using the median of entire data cube.\n\nReferences\n\nMarois et al. 2006 Angular Differential Imaging: A Powerful High-Contrast Imaging Technique\n\n\n\n\n\n","category":"type"},{"location":"api/#API/Reference","page":"API/Reference","title":"API/Reference","text":"","category":"section"},{"location":"api/","page":"API/Reference","title":"API/Reference","text":"For now, here is a dump of all documented functions and types.","category":"page"},{"location":"api/#Index","page":"API/Reference","title":"Index","text":"","category":"section"},{"location":"api/","page":"API/Reference","title":"API/Reference","text":"","category":"page"},{"location":"api/#API/Reference-2","page":"API/Reference","title":"API/Reference","text":"","category":"section"},{"location":"api/","page":"API/Reference","title":"API/Reference","text":"ADI.ADIAlgorithm\nADI.LinearAlgorithm\nreconstruct\ndecompose","category":"page"},{"location":"api/#ADI.ADIAlgorithm","page":"API/Reference","title":"ADI.ADIAlgorithm","text":"ADI.ADIAlgorithm\n\nThis abstract type is used for defining ADI algorithms. See the extended help (??ADIAlgorithm) for interface details.\n\nExtended help\n\nInterface\n\nTo extend ADIAlgorithm you may implement the following\n\nfunction default description\nreconstruct  Subroutine for creating the full reconstructed cube with the PSF\n(::ADIAlgorithm) subtracts output of reconstruct, then derotates and collapses Subroutine for returning the reduced residual cube\n\n\n\n\n\n","category":"type"},{"location":"api/#ADI.LinearAlgorithm","page":"API/Reference","title":"ADI.LinearAlgorithm","text":"ADI.LinearAlgorithm <: ADI.ADIAlgorithm\n\nThis abstract type is used for defining linear ADI algorithms. See the extended help (??LinearAlgorithm) for interface details.\n\nExtended help\n\nInterface\n\nTo extend LinearAlgorithm you may implement the following\n\nfunction default description\ndecompose  Subroutine for fitting the linear basis and coefficients as unrolled matrices\nreconstruct Computes the inner product of the design matrix and weights from decompose Subroutine for creating the full reconstructed cube with the PSF\n(::LinearAlgorithm) subtracts output of reconstruct, then derotates and collapses Subroutine for returning the reduced residual cube\n\n\n\n\n\n","category":"type"},{"location":"api/#ADI.reconstruct","page":"API/Reference","title":"ADI.reconstruct","text":"reconstruct(::ADIAlgorithm, cube, angles, [cube_ref]; kwargs...)\n\nReconstruct the PSF approximation for the given algorithm, using cube_ref as the reference cube if given.\n\nExamples\n\njulia> cube, angles = # load data\n\njulia> S = reconstruct(PCA(10), cube, angles);\n\njulia> size(S) == size(cube)\ntrue\n\njulia> flat_res = collapse(cube .- S, angles); # form resid, derotate, and combine\n\n\n\n\n\n","category":"function"},{"location":"api/#ADI.decompose","page":"API/Reference","title":"ADI.decompose","text":"ADI.decompose(alg::LinearAlgorithm, cube, angles, [cube_ref]; kwargs...)\n\nReturn the basis and coefficients fit by alg. This process generally requires fitting a basis from cube (or cube_ref) and then fitting the coefficients that project cube onto that basis. The inner-product of the two outputs should for an approximate reconstruction of the reference used.\n\nExamples\n\njulia> cube, angles = # load data\n\njulia> A, w = decompose(PCA(5), cube, angles);\n\njulia> S = reconstruct(PCA(5), cube, angles);\n\njulia> S ≈ expand(w * A) # inner product reshaped into cube\ntrue\n\n\n\n\n\n","category":"function"},{"location":"algorithms/greeds/#greeds","page":"GreeDS","title":"GreeDS","text":"","category":"section"},{"location":"algorithms/greeds/#API/Reference","page":"GreeDS","title":"API/Reference","text":"","category":"section"},{"location":"algorithms/greeds/","page":"GreeDS","title":"GreeDS","text":"GreeDS","category":"page"},{"location":"algorithms/greeds/#ADI.GreeDS","page":"GreeDS","title":"ADI.GreeDS","text":"GreeDS(alg=PCA(); threshold=0.0, progress=true)\nGreeDS(ncomps; threshold=0.0, progress=true)\n\nPerforms the greedy disk subtraction (GreeDS) algorithm.\n\nThis method is an iterative approach to standard ADI reduction which seeks to minimize over-subtraction by constraining the low-rank matrix approximation from alg.\n\nFor large data cubes the iteration can cause slowdowns, so a progress bar is provided using the ProgressLogging API along with the progress keyword. It won't appear without a logging backend, such as TerminalLoggers.\n\nAlgorithms\n\nAlthough the original paper explicitly uses PCA, we allow use of any linear ADI algorithm that is characterized by ncomps. By default, uses PCA. If ncomps are provided, will default to PCA as well.\n\nReferences\n\nPairet et al. 2018 \"Reference-less algorithm for circumstellar disks imaging\"\nPairet et al. 2020 \"MAYONNAISE: a morphological components analysis pipeline for circumstellar disks and exoplanets imaging in the near infrared\"\n\n\n\n\n\n","category":"type"},{"location":"examples/betapictoris/","page":"ADI Reduction of beta Pictoris","title":"ADI Reduction of beta Pictoris","text":"EditURL = \"https://github.com/JuliaHCI/ADI.jl/blob/master/examples/betapictoris.jl\"","category":"page"},{"location":"examples/betapictoris/#ADI-Reduction-of-\\beta-Pictoris","page":"ADI Reduction of beta Pictoris","title":"ADI Reduction of beta Pictoris","text":"","category":"section"},{"location":"examples/betapictoris/","page":"ADI Reduction of beta Pictoris","title":"ADI Reduction of beta Pictoris","text":"This example will walk through a full reduction and some analysis of beta Pictoris in order to show the basic usage of ADI.jl for high-contrast imaging. beta Pictoris is a known exoplanet host with many publications regarding the direct images of its substellar companion and circumstellar disk.","category":"page"},{"location":"examples/betapictoris/","page":"ADI Reduction of beta Pictoris","title":"ADI Reduction of beta Pictoris","text":"What will not be covered in this example are the basics of Julia, the fine details of ADI post-processing, or any reference documentation.","category":"page"},{"location":"examples/betapictoris/","page":"ADI Reduction of beta Pictoris","title":"ADI Reduction of beta Pictoris","text":"","category":"page"},{"location":"examples/betapictoris/#Setup","page":"ADI Reduction of beta Pictoris","title":"Setup","text":"","category":"section"},{"location":"examples/betapictoris/","page":"ADI Reduction of beta Pictoris","title":"ADI Reduction of beta Pictoris","text":"Let's begin by importing the necessary libraries. You may need to add these packages if they are not already on your system.","category":"page"},{"location":"examples/betapictoris/","page":"ADI Reduction of beta Pictoris","title":"ADI Reduction of beta Pictoris","text":"(@v1.5) pkg> add DataFrames HCIDatasets Plots","category":"page"},{"location":"examples/betapictoris/","page":"ADI Reduction of beta Pictoris","title":"ADI Reduction of beta Pictoris","text":"In addition, a Project.toml file exists in the examples/ folder with the necessary dependencies. Start the REPL in the base ADI.jl folder, then from Pkg mode","category":"page"},{"location":"examples/betapictoris/","page":"ADI Reduction of beta Pictoris","title":"ADI Reduction of beta Pictoris","text":"(@v1.5) pkg> activate examples\n(examples) pkg> instantiate\njulia> include(\"examples/betapictoris.jl\")","category":"page"},{"location":"examples/betapictoris/","page":"ADI Reduction of beta Pictoris","title":"ADI Reduction of beta Pictoris","text":"","category":"page"},{"location":"examples/betapictoris/","page":"ADI Reduction of beta Pictoris","title":"ADI Reduction of beta Pictoris","text":"using ADI\nusing DataFrames\nusing HCIDatasets: BetaPictoris\nusing Plots\n\n# set up plotting\nfunction imshow(img; kwargs...)\n    ylim = extrema(axes(img, 1))\n    xlim = extrema(axes(img, 2))\n    heatmap(axes(img)..., img; aspect_ratio=1, xlim=xlim, ylim=ylim, kwargs...)\nend;\nnothing #hide","category":"page"},{"location":"examples/betapictoris/#Data-Reduction","page":"ADI Reduction of beta Pictoris","title":"Data Reduction","text":"","category":"section"},{"location":"examples/betapictoris/","page":"ADI Reduction of beta Pictoris","title":"ADI Reduction of beta Pictoris","text":"Here we load the data for beta Pictoris from NaCo at the VLT. You may be prompted to download the data; see HCIDatasets.jl for more details.","category":"page"},{"location":"examples/betapictoris/","page":"ADI Reduction of beta Pictoris","title":"ADI Reduction of beta Pictoris","text":"cube, angles = BetaPictoris[:cube, :pa];\nnothing #hide","category":"page"},{"location":"examples/betapictoris/","page":"ADI Reduction of beta Pictoris","title":"ADI Reduction of beta Pictoris","text":"To reduce the data, we need an algorithm. In ADI.jl we currently have median subtraction, PCA, NMF, and fixed-point GreeDS. These algorithms are treated as \"objects\" in the sense that we initialize them with options and then pass them around inside the ADI.jl framework to retrieve the results we want.","category":"page"},{"location":"examples/betapictoris/","page":"ADI Reduction of beta Pictoris","title":"ADI Reduction of beta Pictoris","text":"The usage for fitting the speckle estimate, projecting and subtracting this estimate from the target cube, and derotating and collapsing the residual all are encompassed by calling the algorithm as a function.","category":"page"},{"location":"examples/betapictoris/","page":"ADI Reduction of beta Pictoris","title":"ADI Reduction of beta Pictoris","text":"alg = PCA(10) # 10 components\nreduced = alg(cube, angles)\nimshow(reduced)","category":"page"},{"location":"examples/betapictoris/","page":"ADI Reduction of beta Pictoris","title":"ADI Reduction of beta Pictoris","text":"To try out different algorithms, all you should have to do is change one line and re-run the remaining code. Let's briefly explore a few different algorithms","category":"page"},{"location":"examples/betapictoris/","page":"ADI Reduction of beta Pictoris","title":"ADI Reduction of beta Pictoris","text":"algs = (alg, NMF(10), Median(), GreeDS(10))\nreduced_frames = [alg(cube, angles) for alg in algs];\nnothing #hide","category":"page"},{"location":"examples/betapictoris/","page":"ADI Reduction of beta Pictoris","title":"ADI Reduction of beta Pictoris","text":"figs = (imshow(reduced, ticks=false) for reduced in reduced_frames)\nplot(\n    figs...,\n    title=[\"PCA(10)\" \"NMF(10)\" \"Median()\" \"GreeDS(10)\"],\n    layout=(2, 2),\n    size=(900, 800),\n    dpi=75\n)","category":"page"},{"location":"examples/betapictoris/","page":"ADI Reduction of beta Pictoris","title":"ADI Reduction of beta Pictoris","text":"You may want to mask out an interior angle since there is an inner limit for our signal to be a real planet (as opposed to systematics from the optical system or noise). We can mask out an interior circle either before processing with the algorithm or afterwards using HCIToolbox.mask_circle (note: HCIToolbox is re-exported by ADI.jl, so all its features are usable without importing it directly).","category":"page"},{"location":"examples/betapictoris/","page":"ADI Reduction of beta Pictoris","title":"ADI Reduction of beta Pictoris","text":"mask_cube = mask_circle(cube, 10)\nmask_reduced = alg(mask_cube, angles)\nimshow(mask_reduced)","category":"page"},{"location":"examples/betapictoris/#S/N-and-Significance-Maps","page":"ADI Reduction of beta Pictoris","title":"S/N and Significance Maps","text":"","category":"section"},{"location":"examples/betapictoris/","page":"ADI Reduction of beta Pictoris","title":"ADI Reduction of beta Pictoris","text":"Now that we have our reduced frame, let's look at the signal-to-noise ratio (SNR, S/N). We use the exact S/N calculation here, implemented in a fast, multi-threaded framework using detectionmap. In order to measure the S/N, though, we need the effective FWHM of our instrument. Normally, we would measure this from an off-axis (or non-coronagraphic) PSF, but for simplicity I'll hard-code a value.","category":"page"},{"location":"examples/betapictoris/","page":"ADI Reduction of beta Pictoris","title":"ADI Reduction of beta Pictoris","text":"fwhm = 4.6\nsnrmap = detectionmap(snr, reduced, fwhm)\nimshow(snrmap)","category":"page"},{"location":"examples/betapictoris/","page":"ADI Reduction of beta Pictoris","title":"ADI Reduction of beta Pictoris","text":"If we want to get the statistical significance, we need to convert from the Student-t confidence interval derived in the S/N to the Gaussian significance. We can accomplish this by calling","category":"page"},{"location":"examples/betapictoris/","page":"ADI Reduction of beta Pictoris","title":"ADI Reduction of beta Pictoris","text":"sigmap = detectionmap(significance, reduced, fwhm)\nimshow(sigmap)","category":"page"},{"location":"examples/betapictoris/","page":"ADI Reduction of beta Pictoris","title":"ADI Reduction of beta Pictoris","text":"Now, let's do some very basic frequentist planet detection by thresholding this significance","category":"page"},{"location":"examples/betapictoris/","page":"ADI Reduction of beta Pictoris","title":"ADI Reduction of beta Pictoris","text":"sigmap_cutoff = @. sigmap > 5\nimshow(sigmap_cutoff)","category":"page"},{"location":"examples/betapictoris/","page":"ADI Reduction of beta Pictoris","title":"ADI Reduction of beta Pictoris","text":"looks like we've successfully pulled out the companion Beta Pictoris b from the data!","category":"page"},{"location":"examples/betapictoris/#Contrast-Curve","page":"ADI Reduction of beta Pictoris","title":"Contrast Curve","text":"","category":"section"},{"location":"examples/betapictoris/","page":"ADI Reduction of beta Pictoris","title":"ADI Reduction of beta Pictoris","text":"We are also interested in analyzing how the algorithm affects our data, especially calculating the throughput and the contrast curve. These measure, effectively, how much signal is lost during the subtraction step of the algorithm and give us an idea of what the limits of our algorithm are with our data.","category":"page"},{"location":"examples/betapictoris/","page":"ADI Reduction of beta Pictoris","title":"ADI Reduction of beta Pictoris","text":"Before we move on, we need to create a PSF model for our data. HCIToolbox.Kernels includes some simple functional PSFs or we can use an empirical PSF. We will use the empirical PSF provided by HCIDatasets for our calculations","category":"page"},{"location":"examples/betapictoris/","page":"ADI Reduction of beta Pictoris","title":"ADI Reduction of beta Pictoris","text":"psf = BetaPictoris[:psf] ./ maximum(BetaPictoris[:psf])\nkern_psf = Kernels.Normal(fwhm);\nnothing #hide","category":"page"},{"location":"examples/betapictoris/","page":"ADI Reduction of beta Pictoris","title":"ADI Reduction of beta Pictoris","text":"plot(\n    imshow(psf),\n    imshow(construct(kern_psf, size(psf))),\n    layout=2,\n    size=(500, 250),\n    cbar=false,\n    ticks=false\n)","category":"page"},{"location":"examples/betapictoris/","page":"ADI Reduction of beta Pictoris","title":"ADI Reduction of beta Pictoris","text":"and now we can calculate the 5σ contrast curve using contrast_curve. Contrast is defined by the ratio of astrophysical flux to Contrast is measured in comparison to the flux of the star; by default ADI.jl finds this flux by measuring the flux with a circular aperture in the central fwhm of the median-combined cube.","category":"page"},{"location":"examples/betapictoris/","page":"ADI Reduction of beta Pictoris","title":"ADI Reduction of beta Pictoris","text":"cc = contrast_curve(alg, cube, angles, psf; fwhm=fwhm, nbranch=6) |> DataFrame\nfirst(filter(row -> isfinite(row.contrast_corr), cc), 5)","category":"page"},{"location":"examples/betapictoris/","page":"ADI Reduction of beta Pictoris","title":"ADI Reduction of beta Pictoris","text":"and lets plot it","category":"page"},{"location":"examples/betapictoris/","page":"ADI Reduction of beta Pictoris","title":"ADI Reduction of beta Pictoris","text":"plot(\n    cc.distance,\n    [cc.contrast_corr cc.contrast],\n    yscale=:log10,\n    xlim=(0, NaN),\n    label=[\"Student-t\" \"Gaussian\"],\n    ylabel=\"5-sigma contrast\",\n    xlabel=\"radius [px]\"\n)","category":"page"},{"location":"examples/betapictoris/","page":"ADI Reduction of beta Pictoris","title":"ADI Reduction of beta Pictoris","text":"You'll notice a pretty severe bump indicating poor contrast where the original companion is! Because this companion is very bright it will bias the contrast measurement.","category":"page"},{"location":"examples/betapictoris/","page":"ADI Reduction of beta Pictoris","title":"ADI Reduction of beta Pictoris","text":"Typically you'd like to fit the companion signal and remove it in a maximum likelihood framework. For convenience here, let's use the :cube_empty entry for BetaPictoris, which already has the companion removed.","category":"page"},{"location":"examples/betapictoris/","page":"ADI Reduction of beta Pictoris","title":"ADI Reduction of beta Pictoris","text":"cube_empty = BetaPictoris[:cube_empty]\nreduced_empty = alg(cube_empty, angles)\nimshow(reduced_empty)","category":"page"},{"location":"examples/betapictoris/","page":"ADI Reduction of beta Pictoris","title":"ADI Reduction of beta Pictoris","text":"cc_empty = contrast_curve(alg, cube_empty, angles, psf; fwhm=fwhm, nbranch=6) |> DataFrame\nfirst(filter(row -> isfinite(row.contrast_corr), cc_empty), 5)","category":"page"},{"location":"examples/betapictoris/","page":"ADI Reduction of beta Pictoris","title":"ADI Reduction of beta Pictoris","text":"plot(\n    cc_empty.distance,\n    [cc_empty.contrast_corr cc_empty.contrast],\n    yscale=:log10,\n    xlim=(0, NaN),\n    label=[\"Student-t\" \"Gaussian\"],\n    ylabel=\"5-sigma contrast\",\n    xlabel=\"radius [px]\"\n)","category":"page"},{"location":"examples/betapictoris/","page":"ADI Reduction of beta Pictoris","title":"ADI Reduction of beta Pictoris","text":"","category":"page"},{"location":"examples/betapictoris/","page":"ADI Reduction of beta Pictoris","title":"ADI Reduction of beta Pictoris","text":"This page was generated using Literate.jl.","category":"page"},{"location":"metrics/#Metrics","page":"Metrics","title":"Metrics","text":"","category":"section"},{"location":"metrics/","page":"Metrics","title":"Metrics","text":"Modules = [ADI.Metrics]","category":"page"},{"location":"metrics/","page":"Metrics","title":"Metrics","text":"ADI.Metrics","category":"page"},{"location":"metrics/#ADI.Metrics","page":"Metrics","title":"ADI.Metrics","text":"ADI.Metrics\n\nThis module provides code for analyzing the results from ADI in a way that is interpretable statistically. Some of the key functionalities are signal-to-noise, significance, the receiver operating characteristic, and the contrast curve.\n\n\n\n\n\n","category":"module"},{"location":"metrics/#Detection-Maps","page":"Metrics","title":"Detection Maps","text":"","category":"section"},{"location":"metrics/","page":"Metrics","title":"Metrics","text":"detectionmap\nsnr\nsignificance\nnoise\nstimmap\nstim_threshold\nMetrics.stim","category":"page"},{"location":"metrics/#ADI.Metrics.detectionmap","page":"Metrics","title":"ADI.Metrics.detectionmap","text":"detectionmap([method=snr], data, fwhm; fill=0)\n\nParallel implementation of arbitrary detection mapping applied to each pixel in the input image. Any invalid values will be set to fill.\n\nThe following methods are provided in the Metrics module:\n\nsnr - signal-to-noise ratio (S/N) using student-t statistics to account for small sample penalty.\nsignificance - Gaussian signifance using student-t statistics to account for small samples penalty.\nnoise - Standard deviation of apertures in each annulus.\n\ntip: Tip\nThis code is automatically multi-threaded, so be sure to set JULIA_NUM_THREADS before loading your runtime to take advantage of it!\n\n\n\n\n\n","category":"function"},{"location":"metrics/#ADI.Metrics.snr","page":"Metrics","title":"ADI.Metrics.snr","text":"snr(data, position, fwhm)\n\nCalculate the signal to noise ratio (SNR, S/N) for a test point at position using apertures of diameter fwhm in a residual frame.\n\nUses the method of Mawet et al. 2014 which includes penalties for small sample statistics. These are encoded by using a student's t-test for calculating the SNR.\n\nnote: Note\nSNR is not equivalent to significance, use significance instead\n\n\n\n\n\n","category":"function"},{"location":"metrics/#ADI.Metrics.significance","page":"Metrics","title":"ADI.Metrics.significance","text":"significance(data, position, fwhm)\n\nCalculates the Gaussian significance from the signal-to-noise ratio (SNR, S/N) for a test point at position using apertures of diameter fwhm in a residual frame.\n\nThe Gaussian signifiance is calculated from converting the SNR confidence limit from a student t distribution to a Gaussian via\n\ntextsig(textSNR) = Phi^-1leftint_0^textSNRt_nu(x)dxright\n\nwhere the degrees of freedom nu is given as 2pi r  Gamma - 2 where r is the radial distance of each pixel from the center of the frame.\n\nSee Also\n\nsnr\n\n\n\n\n\n","category":"function"},{"location":"metrics/#ADI.Metrics.noise","page":"Metrics","title":"ADI.Metrics.noise","text":"noise(data, position, fwhm)\n\nCalculate the statistical noise for a test point at position using apertures of diameter fwhm in a residual frame.\n\nUses the standard deviation of the apertures in the entire annulus. This is distinct from the snr noise calculation, which defines a confidence interval using student-t statistics. This means you cannot simply create a noise map and divide it from the signal to create an equivalent S/N map.\n\n\n\n\n\n","category":"function"},{"location":"metrics/#ADI.Metrics.stimmap","page":"Metrics","title":"ADI.Metrics.stimmap","text":"stimmap(residuals, angles)\n\nCalculate the standardized trajectory intensity mean (STIM) map. The inputs are a cube of residuals and the corresponding parallactic angles.\n\nThis method seeks to improve upon the typical student-t S/N tests (snr, significance) by calculating statistics in the temporal domain instead of the spatial domain. This is why the full residual cube is required rather than a reduced frame. \n\nIn particular, the STIM map is robust to detections with multiple objects or extended sources within the same annuli, which results in very high noise estimates using spatial methods. The STIM map also performs better at small angular separations, since the temporal domain has no limitations from limited resolution elements.\n\nPairet et al. 2019 derives a detection threshold of τ = 0.5 for the STIM map. The detection threshold can be calculated for a specific dataset using stim_threshold.\n\nExamples\n\njulia> cube, angles = # load data\n\njulia> L = reconstruct(PCA(10), cube, angles);\n\njulia> S = cube .- L;\n\njulia> sm = stimmap(S, angles);\n\nReferences\n\nPairet et al. 2019 \"STIM map: detection map for exoplanets imaging beyond asymptotic Gaussian residual speckle noise\"\n\nSee Also\n\nstim_threshold\n\n\n\n\n\n","category":"function"},{"location":"metrics/#ADI.Metrics.stim_threshold","page":"Metrics","title":"ADI.Metrics.stim_threshold","text":"stim_threshold([stimmap, ] residuals, angles)\n\nCalculate the detection threshold for the standardized trajectory intensity mean (STIM) map. This method uses the same residual cube as stimmap but adds an additional step of estimating the residual noise by derotating the residuals with the opposite parallactic angles.\n\nIf the STIM map has already been calculated, it can be passed in, otherwise it will be calculated in addition to the noise map. Note this will not return the STIM map, only the threshold.\n\nThe threshold is derived in section 5.1 of Pairet et al. 2019 as the ratio of the number of pixels above the approximated noise map. They found a value of τ = 0.5 to be typical.\n\nExamples\n\njulia> cube, angles = # load data\n\njulia> L = reconstruct(PCA(10), cube, angles);\n\njulia> S = cube .- L;\n\njulia> sm = stimmap(S, angles);\n\njulia> τ = stim_threshold(sm, S, angles);\n\nReferences\n\nPairet et al. 2019 \"STIM map: detection map for exoplanets imaging beyond asymptotic Gaussian residual speckle noise\"\n\nSee Also\n\nstimmap\n\n\n\n\n\n","category":"function"},{"location":"metrics/#ADI.Metrics.stim","page":"Metrics","title":"ADI.Metrics.stim","text":"Metrics.stim(cube; dims)\n\nCalculates the STIM map of a derotated cube along the given dims. dims should correspond to the temporal axis of the cube. The STIM statistic is the slice mean divided by the slice standard deviation. Invalid values will become 0.\n\n\n\n\n\n","category":"function"},{"location":"metrics/#Throughput","page":"Metrics","title":"Throughput","text":"","category":"section"},{"location":"metrics/","page":"Metrics","title":"Metrics","text":"throughput","category":"page"},{"location":"metrics/#ADI.Metrics.throughput","page":"Metrics","title":"ADI.Metrics.throughput","text":"throughput(alg, cube, angles, psf, args...;\n           fwhm, nbranch=1, theta=0, inner_rad=1,\n           fc_rad_sep=3, snr=100, kwargs...)\n\nCalculate the throughput of alg by injecting fake companions into cube and measuring the relative photometry of each companion in the reduced frame. The photometry is measured using a circular aperture with a diameter matching the fwhm. Any additional args or kwargs will be passed to alg when it is called.\n\nKeyword Arguments\n\nnbranch - number of azimuthal branches to use\ntheta - position angle of initial branch\ninner_rad - position of innermost planet in FWHM\nfc_rad_sep - the separation between planets in FWHM for a single reduction\nsnr - the target signal to noise ratio of the injected planets\nreduced_empty - the collapsed residual frame for estimating the noise. Will process using alg if not provided.\n\n\n\n\n\nthroughput(alg, cube, angls, psf, position, args...;\n           fwhm, snr=100, reduced_empty=nothing,\n           verbose=true, kwargs...)\n\nCalculate the throughput of alg by injecting psf into cube at the given position and measuring the relative photometry of the companion in the reduced frame. The photometry is measured using a circular aperture with a diameter matching the fwhm. Any additional args or kwargs will be passed to alg when it is called.\n\nIf position is a tuple or a vector, it will be parsed as the cartesian coordinate (x, y). If position is a CoordinateTransformations.Polar it will be parsed as polar coordinates from the center of the cube. Note the Polar type expects angles in radians.\n\nKeyword Arguments\n\nfwhm - the full width at half-maximum\nsnr - the target signal to noise ratio of the injected planets\nreduced_empty - the collapsed residual frame for estimating the noise. Will process using alg if not provided.\nverbose - show informative messages during process\n\n\n\n\n\n","category":"function"},{"location":"metrics/#Contrast-Curve","page":"Metrics","title":"Contrast Curve","text":"","category":"section"},{"location":"metrics/","page":"Metrics","title":"Metrics","text":"contrast_curve\nMetrics.subsample_contrast\nMetrics.estimate_starphot","category":"page"},{"location":"metrics/#ADI.Metrics.contrast_curve","page":"Metrics","title":"ADI.Metrics.contrast_curve","text":"contrast_curve(alg, cube, angles, psf, args...;\n               fwhm, sigma=5, nbranch=1, theta=0, inner_rad=1,\n               starphot=Metrics.estimate_starphot(cube, fwhm),\n               fc_rad_sep=3, snr=100, k=2, smooth=true,\n               subsample=true, kwargs...)\n\nCalculate the throughput-calibrated contrast. This first processes the algorithmic throughput by injecting instances of psf into cube. These are processed through alg and the ratio of the recovered flux to the injected flux is calculated. These companions are injected in resolution elements across the frame, which can be changed via the various keyword arguments.\n\nThe throughput can only be calculated for discrete resolution elements, but we typically want a much smoother curve. To accomplish this, we measure the noise (the standard deviation of all resolution elements in an annulus at a given radius) for every pixel in increasing radii. We then interpolate the throughput to this grid and return the subsampled curves.\n\nReturned Fields\n\ndistance - The radial distance (in pixels) for each measurement\ncontrast - The Gaussian sensitivity\ncontrast_corr - The Student-t sensitivity\nnoise - The noise measured for each distance\nthroughput - The throughput measured for each distance.\n\nKeyword Arguments\n\nsigma - The confidence limit in terms of Gaussian standard deviations\nstarphot - The flux of the star. By default calculates the flux in the central core.\n\nInjection Options (See also throughput)\n\nnbranch - number of azimuthal branches to use\ntheta - position angle of initial branch\ninner_rad - position of innermost planet in FWHM\nfc_rad_sep - the separation between planets in FWHM for a single reduction\nsnr - the target signal to noise ratio of the injected planets\n\nSubsampling Options (See also Metrics.subsample_contrast)\n\nsubsample - If true, subsamples the throughput measurements to increase density of curve\nk - The order of the BSpline used for subsampling the throughput\nsmooth - If true, will smooth the subsampled noise measurements with a 2nd order Savitzky-Golay filter\n\ntip: Tip\nIf you prefer a tabular format, simply pipe the output of this function into any type supporting the Tables.jl interface, e.g.contrast_curve(alg, cube, angles, psf; fwhm=fwhm) |> DataFrame\n\n\n\n\n\n","category":"function"},{"location":"metrics/#ADI.Metrics.subsample_contrast","page":"Metrics","title":"ADI.Metrics.subsample_contrast","text":"Metrics.subsample_contrast(empty_frame, distance, throughput;\n                           fwhm, starphot, sigma=5, inner_rad=1,\n                           theta=0, smooth=true, k=2)\n\nHelper function to subsample and smooth a contrast curve.\n\nContrast curves, by definition, are calculated with discrete resolution elements. This can cause contrast curves to have very few points instead of appearing as a continuously measured statistic across the pixels. We alleviate this by sub-sampling the throughput (via BSpline interpolation) across each pixel (instead of each resolution element).\n\nThe noise can be found efficiently enough, so rather than interpolate we measure the noise in annuli of width fwhm increasing in distance by 1 pixel. We measure this noise in empty_frame, which should be a 2D reduced ADI frame.\n\nThe noise measurements can be noisy, so a 2nd order Savitzky-Golay filter can be applied via smooth. This fits a quadratic polynomial over a window of fwhm/2 points together to reduce high-frequency jitter.\n\nExamples\n\nHere is an example which calculates the exact contrast curve in addition to a subsampled curve without re-calculating the throughput.\n\ncube, angles, psf = # load data\n\nalg = PCA(10)\ncc = contrast_curve(alg, cube, angles, psf; fwhm=8.4, subsample=false)\nreduced_empty = alg(cube, angles)\ncc_sub = Metrics.subsample_contrast(reduced_empty, cc.distance, cc.throughput; fwhm=8.4)\n\n\n\n\n\n","category":"function"},{"location":"metrics/#ADI.Metrics.estimate_starphot","page":"Metrics","title":"ADI.Metrics.estimate_starphot","text":"Metrics.estimate_starphot(cube, fwhm)\nMetrics.estimate_starphot(frame, fwhm)\n\nSimple utility to estimate the stellar photometry by placing a circular aperture with fwhm diameter in the center of the frame. If a cube is provided, first the median frame will be found.\n\n\n\n\n\n","category":"function"},{"location":"introduction/#Introduction-to-High-Contrast-Imaging","page":"Introduction to HCI","title":"Introduction to High-Contrast Imaging","text":"","category":"section"},{"location":"introduction/","page":"Introduction to HCI","title":"Introduction to HCI","text":"This will serve as a brief primer to high-contrast imaging (HCI) to illustrate the concepts and themes prevalent within this package. This is not meant to be an exhaustive lecture note on the topic, but more of a gentle introduction.","category":"page"},{"location":"introduction/","page":"Introduction to HCI","title":"Introduction to HCI","text":"If you are comfortable with HCI topics, consider skipping to the Getting Started section to get introduced to ADI.jl, browse the Examples to see sample workflows, or browse through the API to start exploring the capabilities of ADI.jl.","category":"page"},{"location":"introduction/#What-is-HCI","page":"Introduction to HCI","title":"What is HCI","text":"","category":"section"},{"location":"introduction/","page":"Introduction to HCI","title":"Introduction to HCI","text":"HCI is an advanced imaging technique comprising modern instrumentation, clever observational techniques, and post-processing algorithms. The goal of HCI is to probe the circumstellar regions of a star in the search for companions, debris disks, and more. The use of large aperture telescopes, adaptive optics (AO), and coronagraphs are the basis of HCI. An example of an image taken with these instruments is shown below.","category":"page"},{"location":"introduction/","page":"Introduction to HCI","title":"Introduction to HCI","text":"(Image: )","category":"page"},{"location":"introduction/","page":"Introduction to HCI","title":"Introduction to HCI","text":"What is notable in this image is that there is a lot of structured noise in the image that is overwhelming any potential companion signal. The center of the image is particularly noisy, which is precisely where we are most interested in searching for exoplanets. This noise is the effect of quasi-static speckles in the focal-plane. These speckles occur from non-common path aberrations in the AO system and are a fundamental part of the data received by these instruments. Improving the quality of instrumentation is an active topic of HCI research, but it is beyond the scope of this introduction.","category":"page"},{"location":"introduction/#adi","page":"Introduction to HCI","title":"Angular Differential Imaging (ADI)","text":"","category":"section"},{"location":"introduction/","page":"Introduction to HCI","title":"Introduction to HCI","text":"Because this noise is fundamental to the data, post-processing must be performed in order to see any circumstellar signal. This post-processing requires us to fit the PSF of the speckles and then remove it. An example of the above frame with the speckles removed is shown below.","category":"page"},{"location":"introduction/","page":"Introduction to HCI","title":"Introduction to HCI","text":"(Image: )","category":"page"},{"location":"introduction/","page":"Introduction to HCI","title":"Introduction to HCI","text":"Unfortunately, there is no companion evident; but the speckles have been removed, so what is left? The exoplanet is still sitting below the statistical noise in this frame, but the noise can be averaged out by combining many frames together. Since we are concerned with subtracting the speckles, we need to be careful and consider how do we fit and subtract the speckles without removing potential companion signal?","category":"page"},{"location":"introduction/","page":"Introduction to HCI","title":"Introduction to HCI","text":"This is where angular differential imaging (ADI) comes in. ADI is an observational technique pioneered in the early 2000s as an extension of roll deconvolution for ground-based telescopes. The core of this process is that the quasi-static speckles are a function of the optical system, not the astrophysical source. Throughout a night of observing we can leverage the rotation of the Earth to make the field-of-view (FOV) appear to rotate (on an Alt-Az mounted telescope with the field rotator disabled). Even though the sky appears to rotate, because the speckles are due to the telescope optics they will not appear to rotate. The animation below shows a cube of data with a bright fake companion that illustrates the sky rotation typical of ADI.","category":"page"},{"location":"introduction/","page":"Introduction to HCI","title":"Introduction to HCI","text":"(Image: )","category":"page"},{"location":"introduction/","page":"Introduction to HCI","title":"Introduction to HCI","text":"By taking this sequence of images (commonly referred to as a cube) we can more easily model and fit the speckle signal separate from any companions. If you median combine the cube as-is, the non-stationary companion signal will attenuate leaving just the speckles. If we derotate the sequence according to the parallactic angles for each frame we align the sky to a common heading. Now we can collapse the derotated sequence and the planet will constructively interfere while the now-rotating speckles will attenuate. The figure below shows these two competing reductions.","category":"page"},{"location":"introduction/","page":"Introduction to HCI","title":"Introduction to HCI","text":"(Image: )","category":"page"},{"location":"introduction/#Post-Processing-Algorithms","page":"Introduction to HCI","title":"Post-Processing Algorithms","text":"","category":"section"},{"location":"introduction/","page":"Introduction to HCI","title":"Introduction to HCI","text":"Using data cubes (as described in the ADI section), we are tasked with fitting the speckles without capturing the rotating companion signal. Quite a few algorithms have been proposed and a thorough discussion of them is beyond the scope of this introduction. For now, let's assume the algorithms are a black-box that produce speckle approximation cubes.","category":"page"},{"location":"introduction/","page":"Introduction to HCI","title":"Introduction to HCI","text":"If we have this cube, all we need to post-process the data is","category":"page"},{"location":"introduction/","page":"Introduction to HCI","title":"Introduction to HCI","text":"Retrieve a speckle estimate cube\nSubtract the speckle estimate from the target cube and form a residual cube\nDerotate the residual cube according to the parallactic angles of the target\nCollapse the derotated residual cube","category":"page"},{"location":"introduction/","page":"Introduction to HCI","title":"Introduction to HCI","text":"Steps 2-4 are shown in the following figure","category":"page"},{"location":"introduction/","page":"Introduction to HCI","title":"Introduction to HCI","text":"(Image: )","category":"page"},{"location":"introduction/","page":"Introduction to HCI","title":"Introduction to HCI","text":"After all this processing, finally the substellar companion HR8799e is evident. Hopefully this shows the difficulty of HCI and builds up part of the process that occurs outside of the reduction you'll be doing with ADI.jl.","category":"page"},{"location":"introduction/#References","page":"Introduction to HCI","title":"References","text":"","category":"section"},{"location":"introduction/","page":"Introduction to HCI","title":"Introduction to HCI","text":"Here is a selection of further reading for information about high-contrast imaging, ADI, and similar techniques","category":"page"},{"location":"introduction/","page":"Introduction to HCI","title":"Introduction to HCI","text":"Traub, Oppenheimer 2010, \"Direct Imaging of Exoplanets\"\nBowler 2016, \"Imaging Extrasolar Giant Planets\"\nPueyo 2018, \"Direct Imaging as a Detection Technique for Exoplanets\"\nMarois et al. 2006, \"Angular Differential Imaging: A Powerful High-Contrast Imaging Technique\"","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = ADI","category":"page"},{"location":"#ADI.jl","page":"Home","title":"ADI.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"(Image: GitHub) (Image: Build Status) (Image: Coverage) (Image: License)","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: JOSS) (Image: DOI)","category":"page"},{"location":"","page":"Home","title":"Home","text":"A package for angular differential imaging (ADI) along with its variants, such as reference differential imaging (RDI) and spectral differential imaging (SDI).","category":"page"},{"location":"#Installation-and-Setup","page":"Home","title":"Installation and Setup","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"ADI.jl is a registered package and can be installed using the Julia package manager. From the Julia REPL, enter Pkg mode (by pressing ])","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia>]\n\n(@v1.5) pkg> add ADI","category":"page"},{"location":"","page":"Home","title":"Home","text":"To exit Pkg mode, just backspace. Once the package is installed it can be imported with","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using ADI","category":"page"},{"location":"","page":"Home","title":"Home","text":"For more information, see the Pkg documentation.","category":"page"},{"location":"#Contributing-and-Support","page":"Home","title":"Contributing and Support","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"(Image: ColPrac: Contributor's Guide on Collaborative Practices for Community Packages)","category":"page"},{"location":"","page":"Home","title":"Home","text":"In general, all contributions should follow ColPrac. Feel free to open an issue or reach out to the developers to coordinate a contribution or discuss ideas. For support with using ADI.jl, please open an issue describing the problem and steps to reproduce it.","category":"page"},{"location":"#License","page":"Home","title":"License","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This work is distributed under the MIT \"expat\" license. See LICENSE for more information.","category":"page"}]
}
